<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SummationByParts.jl</title><meta name="title" content="Reference · SummationByParts.jl"/><meta property="og:title" content="Reference · SummationByParts.jl"/><meta property="twitter:title" content="Reference · SummationByParts.jl"/><meta name="description" content="Documentation for SummationByParts.jl."/><meta property="og:description" content="Documentation for SummationByParts.jl."/><meta property="twitter:description" content="Documentation for SummationByParts.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SummationByParts.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Build-Operators"><span>Build Operators</span></a></li><li><a class="tocitem" href="#Cubature-Module"><span>Cubature Module</span></a></li><li><a class="tocitem" href="#Differentiation"><span>Differentiation</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li><li><a class="tocitem" href="#Mapping"><span>Mapping</span></a></li><li><a class="tocitem" href="#Optimizer-Module"><span>Optimizer Module</span></a></li><li><a class="tocitem" href="#OrthoPoly-Module"><span>OrthoPoly Module</span></a></li><li><a class="tocitem" href="#Outer-Constructors"><span>Outer Constructors</span></a></li><li><a class="tocitem" href="#SymCubatures-Module"><span>SymCubatures Module</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/OptimalDesignLab/SummationByParts.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Build-Operators">Build Operators</a></li><li><a href="#Cubature-Module">Cubature Module</a></li><li><a href="#Differentiation">Differentiation</a></li><li><a href="#Integration">Integration</a></li><li><a href="#Mapping">Mapping</a></li><li><a href="#Optimizer-Module">Optimizer Module</a></li><li><a href="#OrthoPoly-Module">OrthoPoly Module</a></li><li><a href="#Outer-Constructors">Outer Constructors</a></li><li><a href="#SymCubatures-Module">SymCubatures Module</a></li><li><a href="#Types">Types</a></li><li><a href="#Utilities">Utilities</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#SummationByParts.AbstractFace"><code>SummationByParts.AbstractFace</code></a></li><li><a href="#SummationByParts.AbstractSBP"><code>SummationByParts.AbstractSBP</code></a></li><li><a href="#SummationByParts.Boundary"><code>SummationByParts.Boundary</code></a></li><li><a href="#SummationByParts.DenseFace"><code>SummationByParts.DenseFace</code></a></li><li><a href="#SummationByParts.Interface"><code>SummationByParts.Interface</code></a></li><li><a href="#SummationByParts.LineSegFace"><code>SummationByParts.LineSegFace</code></a></li><li><a href="#SummationByParts.LineSegSBP"><code>SummationByParts.LineSegSBP</code></a></li><li><a href="#SummationByParts.SparseFace"><code>SummationByParts.SparseFace</code></a></li><li><a href="#SummationByParts.SparseTetSBP"><code>SummationByParts.SparseTetSBP</code></a></li><li><a href="#SummationByParts.SparseTriSBP"><code>SummationByParts.SparseTriSBP</code></a></li><li><a href="#SummationByParts.SymCubatures.LineSymCub"><code>SummationByParts.SymCubatures.LineSymCub</code></a></li><li><a href="#SummationByParts.SymCubatures.OperType"><code>SummationByParts.SymCubatures.OperType</code></a></li><li><a href="#SummationByParts.SymCubatures.PointSymCub"><code>SummationByParts.SymCubatures.PointSymCub</code></a></li><li><a href="#SummationByParts.SymCubatures.SymCub"><code>SummationByParts.SymCubatures.SymCub</code></a></li><li><a href="#SummationByParts.SymCubatures.TetSymCub"><code>SummationByParts.SymCubatures.TetSymCub</code></a></li><li><a href="#SummationByParts.SymCubatures.TriSymCub"><code>SummationByParts.SymCubatures.TriSymCub</code></a></li><li><a href="#SummationByParts.TetFace"><code>SummationByParts.TetFace</code></a></li><li><a href="#SummationByParts.TetSBP"><code>SummationByParts.TetSBP</code></a></li><li><a href="#SummationByParts.TetSparseFace"><code>SummationByParts.TetSparseFace</code></a></li><li><a href="#SummationByParts.TriFace"><code>SummationByParts.TriFace</code></a></li><li><a href="#SummationByParts.TriSBP"><code>SummationByParts.TriSBP</code></a></li><li><a href="#SummationByParts.TriSparseFace"><code>SummationByParts.TriSparseFace</code></a></li><li><a href="#SummationByParts.Cubature.cubatureresidual-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.LineSymCub{T}, Int64}} where T"><code>SummationByParts.Cubature.cubatureresidual</code></a></li><li><a href="#SummationByParts.Cubature.equivalenceconstant-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}, Int64}} where T"><code>SummationByParts.Cubature.equivalenceconstant</code></a></li><li><a href="#SummationByParts.Cubature.getTetCubatureDiagE"><code>SummationByParts.Cubature.getTetCubatureDiagE</code></a></li><li><a href="#SummationByParts.Cubature.getTetCubatureGamma"><code>SummationByParts.Cubature.getTetCubatureGamma</code></a></li><li><a href="#SummationByParts.Cubature.getTetCubatureOmega"><code>SummationByParts.Cubature.getTetCubatureOmega</code></a></li><li><a href="#SummationByParts.Cubature.getTriCubatureDiagE"><code>SummationByParts.Cubature.getTriCubatureDiagE</code></a></li><li><a href="#SummationByParts.Cubature.getTriCubatureForTetFaceDiagE"><code>SummationByParts.Cubature.getTriCubatureForTetFaceDiagE</code></a></li><li><a href="#SummationByParts.Cubature.getTriCubatureGamma"><code>SummationByParts.Cubature.getTriCubatureGamma</code></a></li><li><a href="#SummationByParts.Cubature.getTriCubatureOmega"><code>SummationByParts.Cubature.getTriCubatureOmega</code></a></li><li><a href="#SummationByParts.Cubature.pointCubature"><code>SummationByParts.Cubature.pointCubature</code></a></li><li><a href="#SummationByParts.Cubature.quadrature"><code>SummationByParts.Cubature.quadrature</code></a></li><li><a href="#SummationByParts.Cubature.quadratureUniform"><code>SummationByParts.Cubature.quadratureUniform</code></a></li><li><a href="#SummationByParts.Cubature.solvecubature!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Cubature.solvecubature!</code></a></li><li><a href="#SummationByParts.Cubature.solvecubatureweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64}} where T"><code>SummationByParts.Cubature.solvecubatureweights!</code></a></li><li><a href="#SummationByParts.Cubature.tetcubature"><code>SummationByParts.Cubature.tetcubature</code></a></li><li><a href="#SummationByParts.Cubature.tricubature"><code>SummationByParts.Cubature.tricubature</code></a></li><li><a href="#SummationByParts.Optimizer.levenberg_marquardt-Union{Tuple{T}, Tuple{Function, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Optimizer.levenberg_marquardt</code></a></li><li><a href="#SummationByParts.Optimizer.pso-Union{Tuple{T}, Tuple{Function, Int64, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Optimizer.pso</code></a></li><li><a href="#SummationByParts.OrthoPoly.diffjacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffjacobipoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffproriolpoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffproriolpoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.jacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.jacobipoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.lglnodes"><code>SummationByParts.OrthoPoly.lglnodes</code></a></li><li><a href="#SummationByParts.OrthoPoly.lgnodes"><code>SummationByParts.OrthoPoly.lgnodes</code></a></li><li><a href="#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.proriolpoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.proriolpoly</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_full-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_full</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a></li><li><a href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a></li><li><a href="#SummationByParts.SymCubatures.calcjacobian-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcjacobian</code></a></li><li><a href="#SummationByParts.SymCubatures.calcjacobianofnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcjacobianofnodes</code></a></li><li><a href="#SummationByParts.SymCubatures.calcjacobianofweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.calcjacobianofweights</code></a></li><li><a href="#SummationByParts.SymCubatures.calcnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcnodes</code></a></li><li><a href="#SummationByParts.SymCubatures.calcweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.calcweights</code></a></li><li><a href="#SummationByParts.SymCubatures.calcweights_symgroup-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.calcweights_symgroup</code></a></li><li><a href="#SummationByParts.SymCubatures.findleftperm!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T"><code>SummationByParts.SymCubatures.findleftperm!</code></a></li><li><a href="#SummationByParts.SymCubatures.getInternalParamMask-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getInternalParamMask</code></a></li><li><a href="#SummationByParts.SymCubatures.getbndrynodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getbndrynodeindices</code></a></li><li><a href="#SummationByParts.SymCubatures.getfacebasedpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacebasedpermutation</code></a></li><li><a href="#SummationByParts.SymCubatures.getfacenodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacenodeindices</code></a></li><li><a href="#SummationByParts.SymCubatures.getfacevertexindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacevertexindices</code></a></li><li><a href="#SummationByParts.SymCubatures.getinteriornodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getinteriornodeindices</code></a></li><li><a href="#SummationByParts.SymCubatures.getneighbourpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getneighbourpermutation</code></a></li><li><a href="#SummationByParts.SymCubatures.getnumboundarynodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getnumboundarynodes</code></a></li><li><a href="#SummationByParts.SymCubatures.getnumfacenodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getnumfacenodes</code></a></li><li><a href="#SummationByParts.SymCubatures.getpermutation-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Vector{Int64}}} where T"><code>SummationByParts.SymCubatures.getpermutation</code></a></li><li><a href="#SummationByParts.SymCubatures.setparams!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.setparams!</code></a></li><li><a href="#SummationByParts.SymCubatures.setweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.setweights!</code></a></li><li><a href="#SummationByParts.absMatrix!"><code>SummationByParts.absMatrix!</code></a></li><li><a href="#SummationByParts.accuracyconstraints"><code>SummationByParts.accuracyconstraints</code></a></li><li><a href="#SummationByParts.basispursuit!"><code>SummationByParts.basispursuit!</code></a></li><li><a href="#SummationByParts.bndrynodalexpansion"><code>SummationByParts.bndrynodalexpansion</code></a></li><li><a href="#SummationByParts.boundaryFaceIntegrate!"><code>SummationByParts.boundaryFaceIntegrate!</code></a></li><li><a href="#SummationByParts.boundaryFaceIntegrate_jac!"><code>SummationByParts.boundaryFaceIntegrate_jac!</code></a></li><li><a href="#SummationByParts.boundaryFaceIntegrate_rev!"><code>SummationByParts.boundaryFaceIntegrate_rev!</code></a></li><li><a href="#SummationByParts.boundaryintegrate!"><code>SummationByParts.boundaryintegrate!</code></a></li><li><a href="#SummationByParts.boundaryintegrate_rev!"><code>SummationByParts.boundaryintegrate_rev!</code></a></li><li><a href="#SummationByParts.boundarymassmatrix"><code>SummationByParts.boundarymassmatrix</code></a></li><li><a href="#SummationByParts.boundaryoperators"><code>SummationByParts.boundaryoperators</code></a></li><li><a href="#SummationByParts.buildMinConditionOperators"><code>SummationByParts.buildMinConditionOperators</code></a></li><li><a href="#SummationByParts.buildfacederivatives"><code>SummationByParts.buildfacederivatives</code></a></li><li><a href="#SummationByParts.buildfacereconstruction"><code>SummationByParts.buildfacereconstruction</code></a></li><li><a href="#SummationByParts.buildinterpolation"><code>SummationByParts.buildinterpolation</code></a></li><li><a href="#SummationByParts.buildoperators"><code>SummationByParts.buildoperators</code></a></li><li><a href="#SummationByParts.buildoperators_pocs"><code>SummationByParts.buildoperators_pocs</code></a></li><li><a href="#SummationByParts.buildsparseoperators"><code>SummationByParts.buildsparseoperators</code></a></li><li><a href="#SummationByParts.calcFaceNormals!"><code>SummationByParts.calcFaceNormals!</code></a></li><li><a href="#SummationByParts.calcFaceNormals_rev!"><code>SummationByParts.calcFaceNormals_rev!</code></a></li><li><a href="#SummationByParts.calcMappingJacobian!"><code>SummationByParts.calcMappingJacobian!</code></a></li><li><a href="#SummationByParts.calcMappingJacobianElement!"><code>SummationByParts.calcMappingJacobianElement!</code></a></li><li><a href="#SummationByParts.calcMappingJacobian_rev!"><code>SummationByParts.calcMappingJacobian_rev!</code></a></li><li><a href="#SummationByParts.calcMatrixEigs!"><code>SummationByParts.calcMatrixEigs!</code></a></li><li><a href="#SummationByParts.calcMatrixEigs_rev!"><code>SummationByParts.calcMatrixEigs_rev!</code></a></li><li><a href="#SummationByParts.calcSparseSolution!"><code>SummationByParts.calcSparseSolution!</code></a></li><li><a href="#SummationByParts.calcminnodedistance"><code>SummationByParts.calcminnodedistance</code></a></li><li><a href="#SummationByParts.calcnodes"><code>SummationByParts.calcnodes</code></a></li><li><a href="#SummationByParts.checkInteriorNodeLocaton"><code>SummationByParts.checkInteriorNodeLocaton</code></a></li><li><a href="#SummationByParts.commuteerror"><code>SummationByParts.commuteerror</code></a></li><li><a href="#SummationByParts.computeConditionNumber"><code>SummationByParts.computeConditionNumber</code></a></li><li><a href="#SummationByParts.conditionObj"><code>SummationByParts.conditionObj</code></a></li><li><a href="#SummationByParts.conditionObjGrad!"><code>SummationByParts.conditionObjGrad!</code></a></li><li><a href="#SummationByParts.deriveTetCubatureDiagE"><code>SummationByParts.deriveTetCubatureDiagE</code></a></li><li><a href="#SummationByParts.deriveTetCubatureGamma"><code>SummationByParts.deriveTetCubatureGamma</code></a></li><li><a href="#SummationByParts.deriveTetCubatureOmega"><code>SummationByParts.deriveTetCubatureOmega</code></a></li><li><a href="#SummationByParts.deriveTriCubatureDiagE"><code>SummationByParts.deriveTriCubatureDiagE</code></a></li><li><a href="#SummationByParts.deriveTriCubatureGamma"><code>SummationByParts.deriveTriCubatureGamma</code></a></li><li><a href="#SummationByParts.deriveTriCubatureOmega"><code>SummationByParts.deriveTriCubatureOmega</code></a></li><li><a href="#SummationByParts.differentiate!"><code>SummationByParts.differentiate!</code></a></li><li><a href="#SummationByParts.differentiateElement!"><code>SummationByParts.differentiateElement!</code></a></li><li><a href="#SummationByParts.differentiateElement_rev!"><code>SummationByParts.differentiateElement_rev!</code></a></li><li><a href="#SummationByParts.differentiate_rev!"><code>SummationByParts.differentiate_rev!</code></a></li><li><a href="#SummationByParts.directionalDifferentiateElement!"><code>SummationByParts.directionalDifferentiateElement!</code></a></li><li><a href="#SummationByParts.edgestabilize!"><code>SummationByParts.edgestabilize!</code></a></li><li><a href="#SummationByParts.eigenvalueObj"><code>SummationByParts.eigenvalueObj</code></a></li><li><a href="#SummationByParts.eigenvalueObjGrad!"><code>SummationByParts.eigenvalueObjGrad!</code></a></li><li><a href="#SummationByParts.facenormal!"><code>SummationByParts.facenormal!</code></a></li><li><a href="#SummationByParts.facenormal_rev!"><code>SummationByParts.facenormal_rev!</code></a></li><li><a href="#SummationByParts.getNumFaceNodes"><code>SummationByParts.getNumFaceNodes</code></a></li><li><a href="#SummationByParts.getnbrnodeindex"><code>SummationByParts.getnbrnodeindex</code></a></li><li><a href="#SummationByParts.getnodepermutation"><code>SummationByParts.getnodepermutation</code></a></li><li><a href="#SummationByParts.integrateBoundaryFunctional!"><code>SummationByParts.integrateBoundaryFunctional!</code></a></li><li><a href="#SummationByParts.integrateBoundaryFunctional_rev!"><code>SummationByParts.integrateBoundaryFunctional_rev!</code></a></li><li><a href="#SummationByParts.integratefunctional!"><code>SummationByParts.integratefunctional!</code></a></li><li><a href="#SummationByParts.integratefunctional_rev!"><code>SummationByParts.integratefunctional_rev!</code></a></li><li><a href="#SummationByParts.interiorFaceIntegrate!"><code>SummationByParts.interiorFaceIntegrate!</code></a></li><li><a href="#SummationByParts.interiorFaceIntegrate_jac!"><code>SummationByParts.interiorFaceIntegrate_jac!</code></a></li><li><a href="#SummationByParts.interiorFaceIntegrate_rev!"><code>SummationByParts.interiorFaceIntegrate_rev!</code></a></li><li><a href="#SummationByParts.interiorfaceintegrate!"><code>SummationByParts.interiorfaceintegrate!</code></a></li><li><a href="#SummationByParts.interiorfaceintegrate_rev!"><code>SummationByParts.interiorfaceintegrate_rev!</code></a></li><li><a href="#SummationByParts.mappingjacobian!"><code>SummationByParts.mappingjacobian!</code></a></li><li><a href="#SummationByParts.mappingjacobian_rev!"><code>SummationByParts.mappingjacobian_rev!</code></a></li><li><a href="#SummationByParts.nodalexpansion"><code>SummationByParts.nodalexpansion</code></a></li><li><a href="#SummationByParts.permuteface!"><code>SummationByParts.permuteface!</code></a></li><li><a href="#SummationByParts.permuteinterface!"><code>SummationByParts.permuteinterface!</code></a></li><li><a href="#SummationByParts.pocs_sparse_s"><code>SummationByParts.pocs_sparse_s</code></a></li><li><a href="#SummationByParts.quadTruncErr"><code>SummationByParts.quadTruncErr</code></a></li><li><a href="#SummationByParts.truncErr"><code>SummationByParts.truncErr</code></a></li><li><a href="#SummationByParts.volumeIntegrateElement!"><code>SummationByParts.volumeIntegrateElement!</code></a></li><li><a href="#SummationByParts.volumeIntegrateElement_rev!"><code>SummationByParts.volumeIntegrateElement_rev!</code></a></li><li><a href="#SummationByParts.volumeintegrate!"><code>SummationByParts.volumeintegrate!</code></a></li><li><a href="#SummationByParts.volumeintegrate_rev!"><code>SummationByParts.volumeintegrate_rev!</code></a></li><li><a href="#SummationByParts.weakDifferentiateElement!"><code>SummationByParts.weakDifferentiateElement!</code></a></li><li><a href="#SummationByParts.weakDifferentiateElement_jac!"><code>SummationByParts.weakDifferentiateElement_jac!</code></a></li><li><a href="#SummationByParts.weakDifferentiateElement_rev!"><code>SummationByParts.weakDifferentiateElement_rev!</code></a></li><li><a href="#SummationByParts.weakdifferentiate!"><code>SummationByParts.weakdifferentiate!</code></a></li><li><a href="#SummationByParts.weakdifferentiate_rev!"><code>SummationByParts.weakdifferentiate_rev!</code></a></li></ul><h2 id="Build-Operators"><a class="docs-heading-anchor" href="#Build-Operators">Build Operators</a><a id="Build-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Build-Operators" title="Permalink"></a></h2><p>Functions used to build the SBP operators.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.bndrynodalexpansion" href="#SummationByParts.bndrynodalexpansion"><code>SummationByParts.bndrynodalexpansion</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.bndrynodalexpansion</strong></p><p>Computes the transformation matrix that maps the Proriol orthogonal polynomials to polynomials that are nodal on the boundary nodes, i.e. if E is the transformation matrix and P is the matrix of Proriol polys, with the polynomials listed by row, then P*E = I, when restricted to the boundary nodes.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>E</code>: transformation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.nodalexpansion" href="#SummationByParts.nodalexpansion"><code>SummationByParts.nodalexpansion</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.nodalexpansion</strong></p><p>Computes the transformation matrix that maps the Proriol orthogonal polynomials to polynomials that are nodal on the cubature nodes, i.e. if C is the transformation matrix and P is the matrix of Proriol polys, with the polynomials listed by row, then P*C = I, when restricted to the nodes.  This function can be used to construct the operators in the spectral-element method of Giraldo and Tayler.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree on the edges</li><li><code>e</code>: maximum degree of bubble functions on the interior</li></ul><p><strong>Outputs</strong></p><ul><li><code>C</code>: transformation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L98-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryoperators" href="#SummationByParts.boundaryoperators"><code>SummationByParts.boundaryoperators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryoperators</strong></p><p>Finds the symmetric part of the SBP operators, <code>Ex</code>, <code>Ey</code> (<code>Ez</code>).  These operators coorespond to boundary integrals in the divergence theorem, and are related to the mass matrices of the boundary faces.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>Ex</code>, <code>Ey</code> (<code>Ez</code>): symmetric parts of the SBP first derivative operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L215-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundarymassmatrix" href="#SummationByParts.boundarymassmatrix"><code>SummationByParts.boundarymassmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundarymassmatrix</strong></p><p>Returns the (dense) mass matrix for a set of nodes on a reference boundary. This mass matrix can be used for boundary integration or to impose boundary conditions weakly.  The array <code>bndryindices</code> is also returned, which is a list of element-node indices for each boundary (see also SymCubatures.getfacenodeindices).</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>Hbndry</code>: reference boundary mass matrix</li><li><code>bndryindices</code>: list of nodes that lie on each boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L355-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.accuracyconstraints" href="#SummationByParts.accuracyconstraints"><code>SummationByParts.accuracyconstraints</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.accuracyconstraints</strong></p><p>Returns the accuracy constraints on the asymmetric part of the SBP stiffness matrices.  These constraints are linear, and for each coordinate-direction operator (i.e. Qx, Qy,...) the system matrix <code>A</code> is the same; only the right-hand side changes.</p><p>The columns in <code>A</code> are ordered assuming only the strictly lower triangular part of the operators are the unknowns.  These unknowns are ordered by row and then column.  For example, entry Q<em>21 = -Q</em>12 is the number 1 variable, and Q<em>32 = -Q</em>23 is the number 3 variable.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li><li><code>E</code>: the symmetric part of the SBP stiffness matrices</li><li><code>dl</code>: (optional) the minimum total degree for the Proriol polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>A</code>: the system matrix for the linear accuracy constraints</li><li><code>bx</code>,<code>by</code> (<code>bz</code>): the right-hand-sides of the accuracy constraints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L410-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.commuteerror" href="#SummationByParts.commuteerror"><code>SummationByParts.commuteerror</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.commuteerror</strong></p><p>Returns the commute-error objective value.  For 2D SBP operators, this is defined as ||H<em>(Dx</em>Dy - Dy<em>Dx)||^2, where the norm is the Frobenius norm.  For 3D operators, the error is defined as ||H</em>(Dx<em>Dy - Dy</em>Dx)||^2 + ||H<em>(Dx</em>Dz - Dz<em>Dx)||^2 + ||H</em>(Dy<em>Dz - Dz</em>Dx||^2.</p><p><strong>Inputs</strong></p><ul><li><code>w</code>: cubature rule weights</li><li><code>Qxpart</code>,<code>Qypart</code> (<code>Qzpart</code>): Q operators that satisfy the accuracy conditions</li><li><code>Z</code>: basis for the null space of the accuracy constraints (may be empty)</li><li><code>reducedsol</code>: the weights for <code>Z</code>; the first [1:numnodes] elements are for Qx</li></ul><p><strong>Outputs</strong></p><ul><li><code>f</code>: commute-error objective value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L543-L562">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildoperators" href="#SummationByParts.buildoperators"><code>SummationByParts.buildoperators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildoperators</strong></p><p>Construct and return the SBP matrix operators, specifically the diagonal norm matrix and the stiffness matrices.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>w</code>: the diagonal norm stored as a 1D array</li><li><code>Q</code>: the stiffness matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L617-L634">source</a></section><section><div><p><strong>Note</strong>: when a fifth input is included, it is interpreted as the degree of the   interior bubble functions, and the Q operators returned are the   spectral-element differentiation operators of Giraldo and Taylor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L792-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildsparseoperators" href="#SummationByParts.buildsparseoperators"><code>SummationByParts.buildsparseoperators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildsparseoperators</strong></p><p>Construct and return sparse SBP matrix operators, specifically the diagonal norm matrix and the stiffness matrices.  These are sparse in the sense that there are zeros in the S matrices, but they are not returned as sparse matrices.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>w</code>: the diagonal norm stored as a 1D array</li><li><code>Q</code>: the stiffness matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L838-L856">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildMinConditionOperators" href="#SummationByParts.buildMinConditionOperators"><code>SummationByParts.buildMinConditionOperators</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildMinConditionOperators</strong></p><p>Construct and return SBP matrix operators that minimize the condition number of a model advection problem.  These operators have diagonal mass and boundary operators.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li><li><code>tol</code>: (optional) gradient norm tolerance for the optimization problem</li><li><code>vertices</code>: (optional) if true, include vertices in the operator</li><li><code>opthist</code>: (optional) if true, show the optimization history</li></ul><p><strong>Outputs</strong></p><ul><li><code>w</code>: the diagonal norm stored as a 1D array</li><li><code>Q</code>: the stiffness matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L973-L994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.getnodepermutation" href="#SummationByParts.getnodepermutation"><code>SummationByParts.getnodepermutation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.getnodepermutation</strong></p><p>The node ordering produced by SymCubature is not convenient for mapping local to global node indices in the global residual assembly procedure.  This function returns a reordering that is more suited for local-to-global mapping.</p><p><em>Note</em>: the edge parameters of <code>cub</code> are assumed to be less than 0.5.</p><p><em>WARNING</em>: the <code>faceperm</code> array has not been thoroughly tested</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>d</code>: maximum polynomial degree for which the SBP operator is exact</li></ul><p><strong>Outputs</strong></p><ul><li><code>perm</code>: a permutation vector of indices</li><li><code>faceperm</code>: a permutation vector for the face indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L1258-L1279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildoperators_pocs" href="#SummationByParts.buildoperators_pocs"><code>SummationByParts.buildoperators_pocs</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildoperators_pocs</strong></p><p>Construct SBP operators using the Projection Onto Convex Sets (POCS) algorithm </p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li><li><code>vertices</code>: (optional) if true, include vertices in the operator</li></ul><p><strong>Outputs</strong></p><ul><li><code>D</code>: the derivative matrices</li><li><code>H</code>: the norm/mass matrix</li><li><code>E</code>: the boundary integration matrices</li><li><code>Q</code>: the stiffness matrices</li><li><code>S</code>: the skew-symmetric matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildoperators.jl#L1473-L1492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildfacereconstruction" href="#SummationByParts.buildfacereconstruction"><code>SummationByParts.buildfacereconstruction</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildfacereconstruction</strong></p><p>Builds a matrix operator that can reconstruct a field from a set of volume nodes to a set of face nodes.  The reconstruction operator is only constructed for one face, but a permutation array is returned that allows the same operator to be applied on all the faces.</p><p><strong>Inputs</strong></p><ul><li><code>facecub</code>: symmetric cubature rule for the face</li><li><code>cub</code>: symmetric cubature rule for the volume</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Returns</strong></p><ul><li><code>R</code>: the volume- to face-node reconstruction operator</li><li><code>perm</code>: a permutation array that allows <code>R</code> to be applied on all faces</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildfaceoperators.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildfacederivatives" href="#SummationByParts.buildfacederivatives"><code>SummationByParts.buildfacederivatives</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildfacederivatives</strong></p><p>Builds matrix operators that can differentiate a polynomial field of degree <code>d</code> from a set of volume nodes to a set of face nodes.  The derivative operators are only constructed for one face, but a permutation array is returned that allows the same operators to be applied on all the faces.</p><p><strong>Note</strong>: the derivative operators are for the tangential and normal directions,   and do not necessarily correspond to the directions ξ and η (and ζ) used for   the volume derivatives.  These face derivatives are intended for edge   stabilization.</p><p><strong>Inputs</strong></p><ul><li><code>facecub</code>: symmetric cubature rule for the face</li><li><code>cub</code>: symmetric cubature rule for the volume</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>d</code>: maximum total degree for the Proriol polynomials</li></ul><p><strong>Returns</strong></p><ul><li><code>D</code>: derivative operators in [face node, vol node, direction] format</li><li><code>perm</code>: a permutation array that allows <code>D</code> to be applied on all faces</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/buildfaceoperators.jl#L194-L219">source</a></section></article><h2 id="Cubature-Module"><a class="docs-heading-anchor" href="#Cubature-Module">Cubature Module</a><a id="Cubature-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Cubature-Module" title="Permalink"></a></h2><p>Funtions for constructing cubature rules.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.cubatureresidual-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.LineSymCub{T}, Int64}} where T" href="#SummationByParts.Cubature.cubatureresidual-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.LineSymCub{T}, Int64}} where T"><code>SummationByParts.Cubature.cubatureresidual</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Cubature.cubatureresidual</strong></p><p>This method computes the residuals, <code>F</code>, between a cubature, defined by <code>cub</code>, and the true value of an integral.  Each residual corresponds with an orthogonal polynomial on the simplex up to degree <code>q</code>.  The Jacobian, <code>dF</code>, of the residual, with respect to the quadrature nodes and weights, is also returned.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: defines the nodes and weights of the cubature via symmetry orbits</li><li><code>q</code>: maximum degree of the othogonal polynomials used in the conditions</li><li><code>calc_grad</code>: indicates whether to calculate the gradients the orthogonal polynomials</li></ul><p><strong>Outputs</strong></p><ul><li><code>F</code>: the accuracy conditions for orthogonal polynomials up to degree q</li><li><code>dF</code>: derivative of F with respect to x, y, (z,) w, in that order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L15-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.equivalenceconstant-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}, Int64}} where T" href="#SummationByParts.Cubature.equivalenceconstant-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}, Int64}} where T"><code>SummationByParts.Cubature.equivalenceconstant</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Cubature.equivalenceconstant{T}</strong></p><p>Computes the equivalence constant for a given cubature; that is, it finds the maximum eigenvalue for the matrix pk^T H pm, where H = diag(weights) and pk denotes the orthogonal polynomial evaluated at the cubature points.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the right simplex</li><li><code>q</code>: maximum degree of polynomial for which the cubature is to be tested</li></ul><p><strong>Outputs</strong></p><ul><li><code>λmax</code>: maximum eigenvalue, which is the equivalence constant</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L2272-L2289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTetCubatureDiagE" href="#SummationByParts.Cubature.getTetCubatureDiagE"><code>SummationByParts.Cubature.getTetCubatureDiagE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTetCubatureDiagE{T}</strong></p><p>Returns a cubature rule and vertices for the SBP DiagE operators on tetrahedra; these are cubatures that have nodes on the boundary that are analogous to LG or LGL quadrature rules, which then leads to diagonal E.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>faceopertype</code>: the operator type on the facets of the tetrahedron</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right tetrahedron</li><li><code>vtx</code>: vertices for the right tetrahedron</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L1955-L1974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTetCubatureGamma" href="#SummationByParts.Cubature.getTetCubatureGamma"><code>SummationByParts.Cubature.getTetCubatureGamma</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTetCubatureGamma{T}</strong></p><p>Returns a cubature rule and vertices for the SBP Gamma operators on tetrahedra; these are operators with (p+1)(p+2)/2 nodes on each face, where, typically, p = (<code>q</code>+1)/2.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right tetrahedron</li><li><code>vtx</code>: vertices for the right tetrahedron</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L1781-L1799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTetCubatureOmega" href="#SummationByParts.Cubature.getTetCubatureOmega"><code>SummationByParts.Cubature.getTetCubatureOmega</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTetCubatureOmega{T}</strong></p><p>Returns a cubature rule and vertices for the SBP Omega operators on tetrahedra; these are cubatures that are analogous to Gauss-Legendre in 1D, and they are strictly internal to the tet. </p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right tetrahedron</li><li><code>vtx</code>: vertices for the right tetrahedron</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L1846-L1864">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTriCubatureDiagE" href="#SummationByParts.Cubature.getTriCubatureDiagE"><code>SummationByParts.Cubature.getTriCubatureDiagE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTriCubatureDiagE{T}</strong></p><p>Returns a cubature rule and vertices for the SBP DiagE operators on triangles; these are cubatures that have nodes on the boundary that correspond with LG or LGL quadrature rules, which then leads to diagonal E.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>vertices</code>: if true then vertices are included</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L928-L947">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTriCubatureForTetFaceDiagE" href="#SummationByParts.Cubature.getTriCubatureForTetFaceDiagE"><code>SummationByParts.Cubature.getTriCubatureForTetFaceDiagE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTriCubatureDiagE{T}</strong></p><p>Returns a cubature rule and vertices for facets of the SBP DiagE operators  on tetrahedra; these should not be used for 2D problems as they do not  satisfy the accruacy requirements along their edge.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>faceopertype</code>: the operator type on the facets of the tetrahedron</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L794-L813">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTriCubatureGamma" href="#SummationByParts.Cubature.getTriCubatureGamma"><code>SummationByParts.Cubature.getTriCubatureGamma</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTriCubatureGamma{T}</strong></p><p>Returns a cubature rule and vertices for the SBP Gamma operators on triangles; these are operators with p+1 nodes on each face, where, typically, p = (<code>q</code>+1)/2.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L587-L605">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.getTriCubatureOmega" href="#SummationByParts.Cubature.getTriCubatureOmega"><code>SummationByParts.Cubature.getTriCubatureOmega</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.getTriCubatureOmega{T}</strong></p><p>Returns a cubature rule and vertices for the SBP Omega operators on triangles; these are cubatures that are analogous to Gauss-Legendre in 1D, and they are strictly internal to the triangle. </p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L673-L691">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.pointCubature" href="#SummationByParts.Cubature.pointCubature"><code>SummationByParts.Cubature.pointCubature</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.pointCubature</strong></p><p>This returns a (trivial) point cubature and default vertex -1</p><p><strong>Inputs</strong></p><ul><li><code>T</code>: the data type used to represent the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for point</li><li><code>vtx</code>: vertex, [-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L433-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.quadrature" href="#SummationByParts.Cubature.quadrature"><code>SummationByParts.Cubature.quadrature</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.quadrature{T}</strong></p><p>This high-level function computes and returns a symmetric cubature of requested accuracy on the interval [-1,1]</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>internal</code>: if true, all nodes are strictly internal (default false)</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the interval [-1,1]</li><li><code>vtx</code>: vertices, [-1,1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L455-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.quadratureUniform" href="#SummationByParts.Cubature.quadratureUniform"><code>SummationByParts.Cubature.quadratureUniform</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.quadratureUniform{T}</strong></p><p>This high-level function computes and returns a uniform cubature of requested accuracy on the interval [-1,1]</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>N</code>: number of nodes (N &gt;= q+1)</li><li><code>T</code>: the data type used to represent the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the interval [-1,1]</li><li><code>vtx</code>: vertices, [-1,1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L521-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.solvecubature!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T" href="#SummationByParts.Cubature.solvecubature!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Cubature.solvecubature!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Cubature.solvecubature!{SymCub{T}}</strong></p><p>Attempts to solve for the nodes and weights of a cubature that is exact for polynomials of degree r &lt;= <code>q</code>.  The nodes and weights of the cubature are defined by <code>cub</code>, which is a parametric abstract type (see symcubatures.jl).</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>q</code>: maximum (desired) degree for which the cubature is exact</li><li><code>mask</code>: array of indicies of parameters and weights that are free</li><li><code>tol</code>: tolerance with which to solve the accuracy conditions</li><li><code>hist</code>: if true, print the residual-norm convergence history</li><li><code>xinit</code>: initial parameter guess</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li></ul><p><strong>In/Outs</strong></p><ul><li><code>cub</code>: on entry, defines the initial guess for the cubature nodes and weights. on exit, defines the nodes and weights that satisfy the desired accuracy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L195-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.solvecubatureweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64}} where T" href="#SummationByParts.Cubature.solvecubatureweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64}} where T"><code>SummationByParts.Cubature.solvecubatureweights!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Cubature.solvecubatureweights!{SymCub{T}}</strong></p><p>Attempts to solve for the weights of a cubature that is exact for polynomials of degree r &lt;= <code>q</code>.  The weights (and nodes) of the cubature are defined by <code>cub</code>, which is a parametric abstract type (see symcubatures.jl).</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum (desired) degree for which the cubature is exact</li><li><code>tol</code>: tolerance with which to solve the accuracy conditions</li><li><code>hist</code>: if true, print the residual-norm convergence history</li></ul><p><strong>In/Outs</strong></p><ul><li><code>cub</code>: on entry, defines the initial guess for the cubature nodes and weights. on exit, defines the nodes and weights that satisfy the desired accuracy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L321-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.tetcubature" href="#SummationByParts.Cubature.tetcubature"><code>SummationByParts.Cubature.tetcubature</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.tetcubature{T}</strong></p><p>This high-level function computes and returns a symmetric cubature of requested accuracy on the right tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li><li><code>internal</code>: if true, all nodes are strictly internal (default false)</li><li><code>facequad</code>: if true, the cubatures&#39; face nodes coincide with a quadrature</li><li><code>tol</code>: tolerance with which to solve the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right tetrahedron</li><li><code>vtx</code>: vertices for the right tetrahedron</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L1755-L1774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Cubature.tricubature" href="#SummationByParts.Cubature.tricubature"><code>SummationByParts.Cubature.tricubature</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Cubature.tricubature{T}</strong></p><p>Deprecated; this function will be removed in the future</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: maximum degree of polynomial for which the cubature is exact</li><li><code>T</code>: the data type used to represent the cubature</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/cubature.jl#L567-L582">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTriCubatureOmega" href="#SummationByParts.deriveTriCubatureOmega"><code>SummationByParts.deriveTriCubatureOmega</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTriCubatureOmega</strong></p><p>This function derives quadrature rules for SBP-Omega operators on the triangle.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numS21</code> : number of S21 orbits (vertex to opposite face)</li><li><code>numS111</code> : number of S111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTriCubatureGamma" href="#SummationByParts.deriveTriCubatureGamma"><code>SummationByParts.deriveTriCubatureGamma</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTriCubatureGamma</strong></p><p>This function derives quadrature rules for SBP-Gamma operators on the triangle.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numS21</code> : number of S21 orbits (vertex to opposite face)</li><li><code>numS111</code> : number of S111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L147-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTriCubatureDiagE" href="#SummationByParts.deriveTriCubatureDiagE"><code>SummationByParts.deriveTriCubatureDiagE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTriCubatureDiagE</strong></p><p>This function derives quadrature rules for SBP-Omega operators on the triangle.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numS21</code> : number of S21 orbits (vertex to opposite face)</li><li><code>numS111</code> : number of S111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li><li><code>xedge</code>: parameters for the edge symmetry groups</li><li><code>xedge_sym_group</code>: list of the symmetry group ordering provided in xedge</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L285-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTetCubatureOmega" href="#SummationByParts.deriveTetCubatureOmega"><code>SummationByParts.deriveTetCubatureOmega</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTetCubatureOmega</strong></p><p>This function derives quadrature rules for SBP-Omega operators on the tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>facecentroid</code> : if true, face centroids are present in the set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numfaceS21</code> : number of S21 face orbits (same tri orbit on face)</li><li><code>numfaceS111</code> : number of S111 face orbits (same tri orbit on face)</li><li><code>numS31</code> : number of S31 orbits (vertex to opposite face)</li><li><code>numS22</code> : number of S22 orbits</li><li><code>numS211</code>: number of S211 orbits</li><li><code>numS1111</code>: number of S1111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L473-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTetCubatureGamma" href="#SummationByParts.deriveTetCubatureGamma"><code>SummationByParts.deriveTetCubatureGamma</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTetCubatureGamma</strong></p><p>This function derives quadrature rules for SBP-Gamma operators on the tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>facecentroid</code> : if true, face centroids are present in the set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numfaceS21</code> : number of S21 face orbits (same tri orbit on face)</li><li><code>numfaceS111</code> : number of S111 face orbits (same tri orbit on face)</li><li><code>numS31</code> : number of S31 orbits (vertex to opposite face)</li><li><code>numS22</code> : number of S22 orbits</li><li><code>numS211</code>: number of S211 orbits</li><li><code>numS1111</code>: number of S1111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L656-L689">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.deriveTetCubatureDiagE" href="#SummationByParts.deriveTetCubatureDiagE"><code>SummationByParts.deriveTetCubatureDiagE</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.deriveTetCubatureDiagE</strong></p><p>This function derives quadrature rules for SBP diagonal-E operators on the tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>q</code>: the degree of the operator</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>facecentroid</code> : if true, face centroids are present in the set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numfaceS21</code> : number of S21 face orbits (same tri orbit on face)</li><li><code>numfaceS111</code> : number of S111 face orbits (same tri orbit on face)</li><li><code>numS31</code> : number of S31 orbits (vertex to opposite face)</li><li><code>numS22</code> : number of S22 orbits</li><li><code>numS211</code>: number of S211 orbits</li><li><code>numS1111</code>: number of S1111 orbits</li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>verbose</code>: print out iteration results</li><li><code>xinit</code>: initial guess of the prameter and/or the parameter and weights</li><li><code>xinit_sym_group</code>: list of the symmetry group ordering provided in xinit</li><li><code>xedge</code>: parameters for the edge symmetry groups</li><li><code>xedge_sym_group</code>: list of the symmetry group ordering provided in xedge</li></ul><p><strong>Outputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: vertices for the right triangle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/derivecubature.jl#L835-L870">source</a></section></article><h2 id="Differentiation"><a class="docs-heading-anchor" href="#Differentiation">Differentiation</a><a id="Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiation" title="Permalink"></a></h2><p>Functions related to strong and weak differentiation using the SBP operators</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.differentiate!" href="#SummationByParts.differentiate!"><code>SummationByParts.differentiate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.differentiate!</strong></p><p>Applies the SBP differentiation matrix operator, D, to data in <code>flux</code> and stores the result in <code>res</code>.  Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-2 array, with the</li></ul><p>first dimension for the local-node index, and the second dimension for the element index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-3 array, with the first dimension for</li></ul><p>the index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.</p><p>Naturally, the number of entries in the dimension of <code>flux</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Dx, etc)</li><li><code>flux</code>: the array that the operator is applied to</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying inv(H)*Q[:,:,di] to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/differentiate.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.differentiateElement!" href="#SummationByParts.differentiateElement!"><code>SummationByParts.differentiateElement!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.differentiateElement!</strong></p><p>This is the single-element variant of differentiate!  Applies the SBP differentiation matrix operator, D, to data in <code>flux</code> and stores the result in <code>res</code>.  Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-1 array, with first</li></ul><p>and only dimension for the local-node index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-2 array, with the first dimension for</li></ul><p>the index of the vector field, and the second dimension for the local-node index.</p><p>Naturally, the number of entries in the dimension of <code>flux</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Dx, etc)</li><li><code>flux</code>: the array that the operator is applied to</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying inv(H)*Q[:,:,di] to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/differentiate.jl#L74-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.differentiate_rev!" href="#SummationByParts.differentiate_rev!"><code>SummationByParts.differentiate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.differentiate_rev!</strong></p><p>This is the reverse differentiated version of differentiate!.  See differentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Dx, etc)</li><li><code>res_bar</code>: vector applied to the left of the D operator</li><li><code>±</code>: PlusFunctor to add to res_bar, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: the result of the vector matrix product between D and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/differentiate_rev.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.differentiateElement_rev!" href="#SummationByParts.differentiateElement_rev!"><code>SummationByParts.differentiateElement_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.differentiateElement_rev!</strong></p><p>This is the reverse differentiated version of differentiateElement!.  See differentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Dx, etc)</li><li><code>res_bar</code>: vector applied to the left of the D operator</li><li><code>±</code>: PlusFunctor to add to res_bar, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: the result of the vector matrix product between D and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/differentiate_rev.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.directionalDifferentiateElement!" href="#SummationByParts.directionalDifferentiateElement!"><code>SummationByParts.directionalDifferentiateElement!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.directionalDifferentiateElement!</strong></p><p>Performs a directional derivative (in reference space) at a given node.  The input field <code>u</code> is for <strong>a single element</strong>, not a collection of elements.</p><p><strong>WARNING</strong>: In the case of a vector field u, the directional derivative is   added to the output Ddir; the user must zero this before.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>dir</code>: a direction vector for the directional derivative</li><li><code>u</code>: the field that is being differentiated (either a scalar or vector)</li><li><code>i</code>: index of the node at which the derivative is desired</li></ul><p><strong>Returns or In/Outs</strong></p><ul><li><code>Ddir</code>: derivative of <code>u</code> in direction <code>dir</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/directionaldifferentiate.jl#L4-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.weakdifferentiate!" href="#SummationByParts.weakdifferentiate!"><code>SummationByParts.weakdifferentiate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.weakdifferentiate!</strong></p><p>Applies the SBP stiffness matrix (or its transpose) to data in <code>flux</code> and adds to or subtracts from <code>res</code>.  Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-2 array, with the</li></ul><p>first dimension for the local-node index, and the second dimension for the element index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-3 array, with the first dimension for</li></ul><p>the index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.</p><p>Naturally, the number of entries in the dimension of <code>flux</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Qx, etc)</li><li><code>flux</code>: the array that the operator is applied to</li><li><code>±</code> : PlusFunctor to add to res, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying Q[:,:,di] to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/weakdifferentiate.jl#L4-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.weakDifferentiateElement!" href="#SummationByParts.weakDifferentiateElement!"><code>SummationByParts.weakDifferentiateElement!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.weakDifferentiateElement!</strong></p><p>This is the single-element variant of weakdifferentiate!.  Applies the SBP stiffness matrix (or its transpose) to data in <code>flux</code> and adds to or subtracts from <code>res</code>.  Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-1 array, with the only</li></ul><p>dimension for the local-node index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-2 array, with the first dimension for</li></ul><p>the index of the vector field, and the second dimension for the local-node index.</p><p>Naturally, the number of entries in the dimension of <code>flux</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Qx, etc)</li><li><code>flux</code>: the array that the operator is applied to</li><li><code>±</code> : PlusFunctor to add to res, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying Q[:,:,di] to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/weakdifferentiate.jl#L93-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.weakdifferentiate_rev!" href="#SummationByParts.weakdifferentiate_rev!"><code>SummationByParts.weakdifferentiate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.weakdifferentiate_rev!</strong></p><p>This is the reverse differentiated version of weakdifferentiate!.  See weakdifferentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Qx, etc)</li><li><code>res_bar</code>: vector applied to the left of the Q operator</li><li><code>±</code> : PlusFunctor to add to res_bar, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: the result of the vector matrix product between Q and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/weakdifferentiate_rev.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.weakDifferentiateElement_rev!" href="#SummationByParts.weakDifferentiateElement_rev!"><code>SummationByParts.weakDifferentiateElement_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.weakDifferentiateElement_rev!</strong></p><p>This is the reverse differentiated version of weakDifferentiateElement!.  See weakdifferentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Qx, etc)</li><li><code>res_bar</code>: vector applied to the left of the Q operator</li><li><code>±</code> : PlusFunctor to add to res_bar, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: the result of the vector matrix product between Q and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/weakdifferentiate_rev.jl#L86-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.weakDifferentiateElement_jac!" href="#SummationByParts.weakDifferentiateElement_jac!"><code>SummationByParts.weakDifferentiateElement_jac!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.weakDifferentiateElement_jac!</strong></p><p>This function applies the SBP stiffness matrix (or its transpose) to a diagonal, or block diagonal, matrix of flux jacobians <code>dfluxdu</code>.  The resulting matrix is added to or subtracted from <code>dresdu</code>.  Different methods are available depending on the rank of <code>dfluxdu</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>dfluxdu</code> is a rank-1 array, with the</li></ul><p>only dimension for the local-node index.  <code>dresdu</code> is a rank-2 array, with size <code>sbp.numnodes</code> x <code>sbp.numnodes</code>.</p><ul><li>For <em>vector</em> fields, <code>dfluxdu</code> is a rank-3 array, with the first and second</li></ul><p>dimensions for indices of the vector field (at a particular node) and the second dimension for the local-node index.  <code>dresdu</code> is a rank-4 array; the first 2 dimensions are of size nvar = size(dfluxdu,1), while the third and fourth dimensions are of size <code>sbp.numnodes</code>.</p><p>Naturally, the number of entries in the dimension of <code>dfluxdu</code> (and <code>dresdu</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>di</code>: direction index of the operator that is desired (di=1 for Qx, etc)</li><li><code>dfluxdu</code>: array of the derivative of the flux w.r.t. the state</li><li><code>±</code> : PlusFunctor to add to res, MinusFunctor to subract</li><li><code>trans</code> (optional): if true, the transpose operation is applied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>dresdu</code>: stores Q[:,:,di]<em>diag(dfluxdu) or Q[:,:,di]&#39;</em>diag(dfluxdu)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/weakdifferentiate_jac.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.edgestabilize!" href="#SummationByParts.edgestabilize!"><code>SummationByParts.edgestabilize!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.edgestabilize!</strong></p><p>Applies edge stabilization to a given field, differentiating in the direction specified by <code>dirvec</code>, and scaling by the <code>tau</code> field.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>dirvec</code>: direction to differentiate in [xi coord, face node, L/R, face] format</li><li><code>tau</code>: scaling term in [face node, face] format</li><li><code>u</code>: field being stablized in [vol node, element] format</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result is stored in [vol node, element] format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/edgestabilize.jl#L3-L22">source</a></section></article><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><p>Functions related to volumne and face integration over a test function using SBP operators.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.integratefunctional!" href="#SummationByParts.integratefunctional!"><code>SummationByParts.integratefunctional!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.integratefunctional!</strong></p><p>Integrates a given scalar (or vector) field over the boundary faces.</p><ul><li>For <em>scalar</em> fields, the dimensions of <code>uface</code> correspond to [face-node index, boundary index] and the scalar functional is a return value</li><li>For <em>vector</em> fields, the dimensions of <code>uface</code> correspond to [field index, face-node index, boundary index] and the dimensions of <code>fun</code> correspond to [field index].</li></ul><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>bndryfaces</code>: list of boundary faces stored as an array of <code>Boundary</code>s</li><li><code>flux</code>:  array of field data that is being integrated</li><li><code>±</code>: PlusFunctor to add to fun, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>fun</code>: functional value (or vector) being <em>contributed</em> to by the integration</li></ul><p><strong>Returns</strong></p><ul><li><code>fun</code>: in the case of the scalar version, the functional value is returned</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L4-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.integrateBoundaryFunctional!" href="#SummationByParts.integrateBoundaryFunctional!"><code>SummationByParts.integrateBoundaryFunctional!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.integrateBoundaryFunctional!</strong></p><p>This is the single-face variant of integratefunctional!.  Integrates a given scalar (or vector) field over the boundary faces.</p><ul><li><p>For <em>scalar</em> fields, the dimensions of <code>uface</code> correspond to [face-node index] and the scalar functional is a return value</p></li><li><p>For <em>vector</em> fields, the dimensions of <code>uface</code> correspond to [field index, face-node index] and the dimensions of <code>fun</code> correspond to [field index].</p></li></ul><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>face</code>: the face of the element to integrate</li><li><code>flux</code>:  array of field data that is being integrated</li><li><code>±</code>: PlusFunctor to add to fun, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>fun</code>: functional value (or vector) being <em>contributed</em> to by the integration</li></ul><p><strong>Returns</strong></p><ul><li><code>fun</code>: in the case of the scalar version, the functional value is returned</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L93-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryintegrate!" href="#SummationByParts.boundaryintegrate!"><code>SummationByParts.boundaryintegrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryintegrate!</strong></p><p>Scales flux values at boundary cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-2 array, with the</li></ul><p>first dimension for the face-node index, and the second dimension for the boundary index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-3 array, with the first dimension for</li></ul><p>the index of the vector field, the second dimension for the face-node index, and the third dimension for the boundary index.</p><p>The dimensions of <code>res</code> are still based on elements; the last dimension is for the element index and the second-last dimension is for the element-local node index.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>bndryfaces</code>: list of boundary faces stored as an array of <code>Boundary</code>s</li><li><code>flux</code>: array of flux data that is being integrated</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of the integration is stored</li></ul><p><strong>WARNING</strong>: the order of the boundaries in <code>bndryfaces</code> and <code>flux</code> must be   consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L167-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryFaceIntegrate!" href="#SummationByParts.boundaryFaceIntegrate!"><code>SummationByParts.boundaryFaceIntegrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryFaceIntegrate!</strong></p><p>This is the single-face variant of boundaryintegrate!. Scales flux values at boundary cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-1 array, with the</li></ul><p>first and only dimension for the face-node index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-2 array, with the first dimension for</li></ul><p>the index of the vector field, and the second dimension for the face-node index.</p><p>The dimensions of <code>res</code> are still based on elements; the last dimension (in the scalar case, the only dimension) is for the element-local node index.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>face</code>: the face of the element to integrate and project back to the element</li><li><code>flux</code>: array of flux data that is being integrated</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of the integration is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L273-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.interiorfaceintegrate!" href="#SummationByParts.interiorfaceintegrate!"><code>SummationByParts.interiorfaceintegrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.interiorfaceintegrate!</strong></p><p>Scales flux values at element-interface cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-2 array, with the</li></ul><p>first dimension for the face-node index, and the second dimension for the interface index.</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-3 array, with the first dimension for</li></ul><p>the index of the vector field, the second dimension for the face-node index, and the third dimension for the interface index.</p><p>The dimensions of <code>res</code> are still based on elements; the last dimension is for the element index and the second-last dimension is for the element-local node index.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>flux</code>: array of flux data that is being integrated</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of the integration is stored</li></ul><p><strong>WARNING</strong>: the order of the interfaces in <code>ifaces</code> and <code>flux</code> must be   consistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L360-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.interiorFaceIntegrate!" href="#SummationByParts.interiorFaceIntegrate!"><code>SummationByParts.interiorFaceIntegrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.interiorFaceIntegrate!</strong></p><p>This is the single-face variant of interiorfaceintegrate!.  Scales flux values at element-interface cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes.  Different methods are available depending on the rank of <code>flux</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>flux</code> is a rank-1 array, with the</li></ul><p>first and only dimension for the face-node index</p><ul><li>For <em>vector</em> fields, <code>flux</code> is a rank-2 array, with the first dimension for</li></ul><p>the index of the vector field, and the second dimension for the face-node index</p><p>The dimensions of <code>resL</code> and <code>resR</code> are still based on elements; the last dimension (in the scalar case, the only dimension) is for the element-local node index.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>flux</code>: array of flux data that is being integrated</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>resL</code>: where the result of the integration is stored for the <em>left</em> element</li><li><code>resR</code>: where the result of the integration is stored for the <em>right</em> element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate.jl#L475-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.integratefunctional_rev!" href="#SummationByParts.integratefunctional_rev!"><code>SummationByParts.integratefunctional_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.integratefunctional_rev!</strong></p><p>This is the reverse differentiated version of integratefunctional!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>bndryfaces</code>: list of boundary faces stored as an array of <code>Boundary</code>s</li><li><code>fun_bar</code>: incoming quantity that multiplies the functional from the left</li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector-Jacobian product.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.integrateBoundaryFunctional_rev!" href="#SummationByParts.integrateBoundaryFunctional_rev!"><code>SummationByParts.integrateBoundaryFunctional_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.integrateBoundaryFunctional_rev!</strong></p><p>This is the reverse differentiated version of integrateBoundaryFunctional!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>face</code>: the face of the element to integrate</li><li><code>fun_bar</code>: incoming quantity that multiplies the functional from the left</li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector-Jacobian product.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L57-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryintegrate_rev!" href="#SummationByParts.boundaryintegrate_rev!"><code>SummationByParts.boundaryintegrate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryintegrate_rev!</strong></p><p>This is the reverse differentiated version of boundaryintegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>bndryfaces</code>: list of boundary faces stored as an array of <code>Boundary</code>s</li><li><code>res_bar</code>: vector applied to the left of the (R^T*B) operator</li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector matrix product between (R^T*B) and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L101-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryFaceIntegrate_rev!" href="#SummationByParts.boundaryFaceIntegrate_rev!"><code>SummationByParts.boundaryFaceIntegrate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryFaceIntegrate_rev!</strong></p><p>This is the reverse differentiated version of boundaryFaceIntegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>face</code>: the face of the element to integrate and project back to the element</li><li><code>res_bar</code>: vector applied to the left of the (R^T*B) operator</li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector matrix product between (R^T*B) and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L207-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.interiorfaceintegrate_rev!" href="#SummationByParts.interiorfaceintegrate_rev!"><code>SummationByParts.interiorfaceintegrate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.interiorfaceintegrate_rev!</strong></p><p>This is the reverse differentiated version of interiorfaceintegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>res_bar</code>: vector applied to the left of the (R^T*B) operator</li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector matrix product between (R^T*B) and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L295-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.interiorFaceIntegrate_rev!" href="#SummationByParts.interiorFaceIntegrate_rev!"><code>SummationByParts.interiorFaceIntegrate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.interiorFaceIntegrate_rev!</strong></p><p>This is the reverse differentiated version of interiorFaceIntegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>flux</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>resL_bar</code>: vector (left element) applied to the left of the (R^T*B) operator </li><li><code>resR_bar</code>: vector (right element) applied to the left of the (R^T*B) operator </li><li><code>±</code>: PlusFunctor to add to <code>flux_bar</code>, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>flux_bar</code>: result of the vector-matrix product</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_rev.jl#L416-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.boundaryFaceIntegrate_jac!" href="#SummationByParts.boundaryFaceIntegrate_jac!"><code>SummationByParts.boundaryFaceIntegrate_jac!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.boundaryFaceIntegrate_jac!</strong></p><p>Given the face-node flux Jacobians, this method computes the Jacobian of the chain boundaryFaceInterpolate! –&gt; face-flux evaluation –&gt; boundaryFaceIntegrate!  and adds the contributions to the relevant element&#39;s Jacobian matrix.  Different methods are available depending on the rank of <code>dfluxdu</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>dfluxdu</code> is a rank-1 array, with the</li></ul><p>only dimension for the face local-node index.  <code>dresdu</code> is the Jacobian of the element residual with respect to the state.</p><ul><li>For <em>vector</em> fields, <code>dfluxdu</code> is a rank-3 array, with the first and second</li></ul><p>dimensions for indices of the vector field (at a particular face node) and the second dimension for the face local-node index.  <code>dresdu</code> is a rank-4 array that is the Jacobian of the element residual with respect to the state; the first 2 dimensions are of size nvar = size(dfluxdu,1), while the third and fourth dimensions are of size <code>sbp.numnodes</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>face</code>: the relevant face (index) of the element</li><li><code>dfluxdu</code>: array of the derivative of the flux w.r.t. the state trace</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>dresdu</code>: Jacobian of element residual w.r.t. the state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_jac.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.interiorFaceIntegrate_jac!" href="#SummationByParts.interiorFaceIntegrate_jac!"><code>SummationByParts.interiorFaceIntegrate_jac!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.interiorFaceIntegrate_jac!</strong></p><p>Given the face-node flux Jacobians, this method computes the Jacobian of the chain interiorFaceInterpolate! –&gt; face-flux evaluation –&gt; interiorFaceIntegrate!  and adds the contributions to the adjacent elements&#39; Jacobians matrices.  Different methods are available depending on the rank of <code>dfluxduL</code> and <code>dfluxduR</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>dfluxduL</code> and <code>dfluxduR</code> are rank-1</li></ul><p>arrays, with the only dimension for the face local-node index.  <code>dresLduL</code> is the Jacobian of the left-element residual with respect to the left-element solution, and similarly for <code>dresLduR</code>, <code>dresRduL</code>, <code>dresRduR</code>.</p><ul><li>For <em>vector</em> fields, <code>dfluxduL</code> and <code>dfluxduR</code> are rank-3 arrays, with the</li></ul><p>first and second dimensions for indices of the vector field (at a particular face node) and the second dimension for the face local-node index.  <code>dresLduL</code> is a rank-4 array that is the Jacobian of the left-element residual with respect to the left-element solution; the first 2 dimensions are of size nvar = size(dfluxduL,1), while the third and fourth dimensions are of size <code>sbp.numnodes</code>.  Similarly for <code>dresLduR</code>, <code>dresRduL</code>, <code>dresRduR</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP AbstractFace type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>dfluxduL</code>: array of the derivative of the flux w.r.t. the left trace</li><li><code>dfluxduR</code>: array of the derivative of the flux w.r.t. the right trace</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>dresLduL</code>: Jacobian of left residual w.r.t. left state</li><li><code>dresLduR</code>: Jacobian of left residual w.r.t. right state</li><li><code>dresRduL</code>: Jacobian of right residual w.r.t. left state</li><li><code>dresRduR</code>: Jacobian of right residual w.r.t. right state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/faceintegrate_jac.jl#L126-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.volumeintegrate!" href="#SummationByParts.volumeintegrate!"><code>SummationByParts.volumeintegrate!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.volumeintegrate!</strong></p><p>Applies the SBP mass matrix operator, H, to data in <code>u</code> and stores the result in <code>res</code>.  Different methods are available depending on the rank of <code>u</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>u</code> is a rank-2 array, with the first</li></ul><p>dimension for the local-node index, and the second dimension for the element index.</p><ul><li>For <em>vector</em> fields, <code>u</code> is a rank-3 array, with the first dimension for the</li></ul><p>index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.</p><p>Naturally, the number of entries in the dimension of <code>u</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>u</code>: the array that the operator is applied to</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying H to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/volumeintegrate.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.volumeIntegrateElement!" href="#SummationByParts.volumeIntegrateElement!"><code>SummationByParts.volumeIntegrateElement!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.volumeIntegrateElement!</strong></p><p>This is the single-element variant of volumeIntegrate!.  Applies the SBP mass matrix operator, H, to data in <code>u</code> and stores the result in <code>res</code>.  Different methods are available depending on the rank of <code>u</code>:</p><ul><li>For <em>scalar</em> fields, it is assumed that <code>u</code> is a rank-1 array, with the first</li></ul><p>and only dimension for the local-node index.</p><ul><li>For <em>vector</em> fields, <code>u</code> is a rank-2 array, with the first dimension for the</li></ul><p>index of the vector field, and the second dimension for the local-node index.</p><p>Naturally, the number of entries in the dimension of <code>u</code> (and <code>res</code>) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>u</code>: the array that the operator is applied to</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>res</code>: where the result of applying H to u is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/volumeintegrate.jl#L63-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.volumeintegrate_rev!" href="#SummationByParts.volumeintegrate_rev!"><code>SummationByParts.volumeintegrate_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.volumeintegrate_rev!</strong></p><p>This is the reverse differentiated version of volumeintegrate!.  See volumeintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>u</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>res_bar</code>: vector applied to the left of the H operator</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>u_bar</code>: the result of the vector matrix product between H and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/volumeintegrate_rev.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.volumeIntegrateElement_rev!" href="#SummationByParts.volumeIntegrateElement_rev!"><code>SummationByParts.volumeIntegrateElement_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.volumeIntegrateElement_rev!</strong></p><p>This is the reverse differentiated version of volumeIntegrateElement!.  See volumeintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>u</code> variable.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>res_bar</code>: vector applied to the left of the H operator</li><li><code>±</code>: PlusFunctor to add to res, MinusFunctor to subract</li></ul><p><strong>In/Outs</strong></p><ul><li><code>u_bar</code>: the result of the vector matrix product between H and <code>res_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/volumeintegrate_rev.jl#L54-L71">source</a></section></article><h2 id="Mapping"><a class="docs-heading-anchor" href="#Mapping">Mapping</a><a id="Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping" title="Permalink"></a></h2><p>Functions related to the calculation of the coordinate mapping Jacobian on elements and faces.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcMappingJacobian!" href="#SummationByParts.calcMappingJacobian!"><code>SummationByParts.calcMappingJacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcMappingJacobian!</strong></p><p>Uses a given set of Lagrangian element nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the Jacobian of the mapping.  The approach varies depending on the dimension of the problem:</p><ul><li>For <em>2-dimensional problems</em> the exact Jacobian of the mapping is used;</li><li>For <em>3-dimensional problems</em> an optimization problem is solved</li></ul><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagrangian node, element]</li><li><code>Eone</code>: Ex<em>one, Ey</em>one (Ez*one); [sbp node, coord, element] see notes below</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: location of the SBP nodes in physical space; [coord, sbp node, element]</li><li><code>dξdx</code>: scaled Jacobian of mapping; [ref coord, phys coord, sbp node, element]</li><li><code>jac</code>: the determinant of the Jacobian; [sbp node, element]</li></ul><p><strong>Notes</strong></p><p>The array <code>Eone</code> is the product of the boundary operators, in physical space, with the vector of ones (see Crean et al., Entropy-Conservative, Multidimensional Summation-By-Parts Discretization of the Euler Equations, as well as the test in <code>test/test_mappingjacobian.jl</code>).  These products are used to define the metric invariants.  <em>They are not needed by the 2-dimensional code</em>, and so this array can be passed empty in that case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcMappingJacobianElement!" href="#SummationByParts.calcMappingJacobianElement!"><code>SummationByParts.calcMappingJacobianElement!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcMappingJacobianElement!</strong></p><p>Single element variant of calcMappingJacobian!.  Uses a given set of Lagrangian element nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the Jacobian of the mapping.  The approach varies depending on the dimension of the problem:</p><ul><li>For <em>2-dimensional problems</em> the exact Jacobian of the mapping is used;</li><li>For <em>3-dimensional problems</em> an optimization problem is solved</li></ul><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagrangian node]</li><li><code>Eone</code>: Ex<em>one, Ey</em>one (Ez*one); [sbp node, coord] see notes below</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: location of the SBP nodes in physical space; [coord, sbp node]</li><li><code>dξdx</code>: the scaled Jacobian of the mapping; [ref coord, phys coord, sbp node]</li><li><code>jac</code>: the determinant of the Jacobian; [sbp node]</li></ul><p><strong>Notes</strong></p><p>The array <code>Eone</code> is the product of the boundary operators, in physical space, with the vector of ones (see Crean et al., Entropy-Conservative, Multidimensional Summation-By-Parts Discretization of the Euler Equations, as well as the test in <code>test/test_mappingjacobian.jl</code>).  These products are used to define the metric invariants.  <em>They are not needed by the 2-dimensional code, and so this array can be passed empty in that case</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian.jl#L238-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.mappingjacobian!" href="#SummationByParts.mappingjacobian!"><code>SummationByParts.mappingjacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.mappingjacobian!</strong></p><p>Evaluates the Jacobian of the mapping from face-reference coordinates to physical coordinates, as well as the determinant of the Jacobian.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>ifaces</code>: list of element interfaces stored as an array of <code>Interface</code>s</li><li><code>x</code>: the physical coordinates in [coord, node, elem] format</li></ul><p><strong>In/Outs</strong></p><ul><li><code>dξdx</code>: the Jacobian in [ξ coord, x coord, face node, L/R, face] format</li><li><code>jac</code>: the determinant in [face node, L/R, face] format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian.jl#L419-L436">source</a></section><section><div><p><strong>SummationByParts.mappingjacobian!</strong></p><p><strong>Deprecated</strong>:</p><p>Evaluates the (scaled) Jacobian of the mapping from reference coordinates to physical coordinates, as well as the determinant of the Jacobian.  The values returned in dξdx are scaled by the determinant, so they have the same units as the boundary measure (i.e. length in 2D, or length^2 in 3D).  This scaling is adopted, because conservation laws written in conservative form in the reference frame use the scaled Jacobian.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>x</code>: the physical coordinates; 1st dim = coord, 2nd dim = node, 3rd dim = elem</li></ul><p><strong>In/Outs</strong></p><ul><li><code>dξdx</code>: the scaled Jacobian of the mapping; 1st dim = ref coord, 2nd dim = phys coord, 3rd dim = node, 3rd dim = elem</li><li><code>jac</code>: the determinant of the Jacobian; 1st dim = node, 2nd dim = elem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian.jl#L484-L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcMappingJacobian_rev!" href="#SummationByParts.calcMappingJacobian_rev!"><code>SummationByParts.calcMappingJacobian_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcMappingJacobian_rev!</strong></p><p>Forms the reverse-mode of algorithmic differentiation product for the method <code>calcMappingJacobian!</code>.  Specifically, it computes <code>xlag_bar</code> = <code>xsbp_bar</code>^T * ∂<code>xsbp</code>/∂<code>xlag</code> + <code>dξdx_bar</code>^T * ∂<code>dξdx</code>/∂<code>xlag</code> + <code>jac_bar</code>^T * ∂<code>jac</code>/∂<code>xlag</code> and <code>Eone_bar</code> = <code>dξdx_bar</code>^T * ∂<code>dξdx</code>/∂<code>xlag</code> where the various quantities are defined below (the <code>_bar</code> denotes the reverse mode).  Note that the input and output order of the arguments follows that used in <code>calcMappingJacobian!</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xsbp_bar</code>: gradient w.r.t. SBP nodes; [coord, sbp node]</li><li><code>dξdx</code>: scaled Jacobian of mapping (as output from calcMappingJacobian!)</li><li><code>dξdx_bar</code>: gradient w.r.t. Jacobian; [ref coord, phys coord, sbp node, element]</li><li><code>jac</code>: the determinant of the Jacobian (as output from calcMappingJacobian!)</li><li><code>jac_bar</code>: gradient w.r.t. determinant of the Jacobian; [sbp node, element]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xlag_bar</code>: gradient w.r.t. Lagrangian nodes; [coord, Lagrangian node, element]</li><li><code>Eone_bar</code>: gradient w.r.t. Ex<em>one, Ey</em>one (Ez*one); [sbp node, coord, element]</li></ul><p><strong>Notes</strong></p><p>See <code>calcMappingJacobian!</code> for an explanation of <code>Eone</code>; it is only needed in the 3D case, but Eone_bar needs to be supplied in both 2D and 3D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian_rev.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.mappingjacobian_rev!" href="#SummationByParts.mappingjacobian_rev!"><code>SummationByParts.mappingjacobian_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.mappingjacobian_rev!</strong></p><p><strong>Deprecated</strong>:</p><p>Forms the reverse-mode of algorithmic differentiation product for the method <code>mappingjacobian!</code>.  Specifically, it computes <code>x_bar</code> = <code>dξdx_bar</code>^T * ∂<code>dξdx</code>/∂<code>x</code> + <code>jac_bar</code>^T * ∂<code>jac</code>/∂<code>x</code> where the various quantities are defined below (the <code>_bar</code> denotes the reverse mode).  Note that the input and output order of the arguments follows that used in <code>mappingjacobian!</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator type</li><li><code>x</code>: the physical coordinates; 1st dim = coord, 2nd dim = node, 3rd dim = elem</li><li><code>dξdx_bar</code>: gradient w.r.t. Jacobian; [ref coord, phys coord, sbp node, element]</li><li><code>jac_bar</code>: gradient w.r.t. determinant of the Jacobian; [sbp node, element]</li></ul><p><strong>In/Outs</strong></p><ul><li><p><code>x_bar</code>: gradient w.r.t. SBP nodes; [coord, Lagrangian node, element]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/mappingjacobian_rev.jl#L330-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcFaceNormals!" href="#SummationByParts.calcFaceNormals!"><code>SummationByParts.calcFaceNormals!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcFaceNormals!</strong></p><p>Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lag node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lag node, face]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: SBP-face nodes in physical space; [coord, sbp node, face]</li><li><code>nrm</code>: scaled face-normal at the sbpface nodes; [component, sbp node, face]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal.jl#L6-L25">source</a></section><section><div><p><strong>SummationByParts.calcFaceNormals!</strong></p><p>Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lag node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lag node, face]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: SBP-face nodes in physical space; [coord, sbp node, face]</li><li><code>nrm</code>: scaled face-normal at the sbpface nodes; [component, sbp node, face]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.facenormal!" href="#SummationByParts.facenormal!"><code>SummationByParts.facenormal!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.facenormal!</strong></p><p>This is the single-face variant of calcFaceNormals!.  Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagrangian node]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: location of the SBP-face nodes in physical space; [coord, sbp node]</li><li><code>nrm</code>: scaled face-normal at the sbpface nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal.jl#L163-L182">source</a></section><section><div><p><strong>SummationByParts.facenormal!</strong></p><p>This is the single-face variant of calcFaceNormals!.  Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagrangian node]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xsbp</code>: location of the SBP-face nodes in physical space; [coord, sbp node]</li><li><code>nrm</code>: scaled face-normal at the sbpface nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal.jl#L163-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcFaceNormals_rev!" href="#SummationByParts.calcFaceNormals_rev!"><code>SummationByParts.calcFaceNormals_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcFaceNormals_rev!</strong></p><p>This is the reverse differentiated version of calcFaceNormals!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>xsbp</code> and <code>nrm</code> variables.</p><p><strong>Note</strong>: <code>xlag</code> must be provided, but is only needed for the <code>TetFace</code> method.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lag node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lag node, face]</li><li><code>xsbp_bar</code>: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node, face]</li><li><code>nrm_bar</code>: multiplies d(nrm)/d(xlag) from the left; [component, sbp node, face]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xlag_bar</code>: result of vector Jacobian product; [coord, Lag node, face]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal_rev.jl#L6-L29">source</a></section><section><div><p><strong>SummationByParts.calcFaceNormals_rev!</strong></p><p>This is the reverse differentiated version of calcFaceNormals!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>xsbp</code> and <code>nrm</code> variables.</p><p><strong>Note</strong>: <code>xlag</code> must be provided, but is only needed for the <code>TetFace</code> method.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lag node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lag node, face]</li><li><code>xsbp_bar</code>: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node, face]</li><li><code>nrm_bar</code>: multiplies d(nrm)/d(xlag) from the left; [component, sbp node, face]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xlag_bar</code>: result of vector Jacobian product; [coord, Lag node, face]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal_rev.jl#L6-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.facenormal_rev!" href="#SummationByParts.facenormal_rev!"><code>SummationByParts.facenormal_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.facenormal_rev!</strong></p><p>This is the reverse differentiated version of facenormal!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>xsbp</code> and <code>nrm</code> variables.</p><p><strong>Note</strong>: <code>xlag</code> must be provided, but is only needed for the <code>TetFace</code> method.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagragnian node]</li><li><code>xsbp_bar</code>: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node]</li><li><code>nrm_bar</code>: multiplies d(nrm)/d(xlag) from the left; [component, sbp node]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xlag_bar</code>: result of vector Jacobian product; [coord, Lagrangian node]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal_rev.jl#L209-L231">source</a></section><section><div><p><strong>SummationByParts.facenormal_rev!</strong></p><p>This is the reverse differentiated version of facenormal!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version&#39;s <code>xsbp</code> and <code>nrm</code> variables.</p><p><strong>Note</strong>: <code>xlag</code> must be provided, but is only needed for the <code>TetFace</code> method.</p><p><strong>Inputs</strong></p><ul><li><code>sbpface</code>: an SBP face operator type</li><li><code>mapdegree</code>: the polynomial degree of the mapping</li><li><code>xref</code>: Lagrangian nodes in reference space; [coord, Lagrangian node]</li><li><code>xlag</code>: Lagrangian nodes in physical space; [coord, Lagragnian node]</li><li><code>xsbp_bar</code>: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node]</li><li><code>nrm_bar</code>: multiplies d(nrm)/d(xlag) from the left; [component, sbp node]</li></ul><p><strong>In/Outs</strong></p><ul><li><code>xlag_bar</code>: result of vector Jacobian product; [coord, Lagrangian node]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/facenormal_rev.jl#L209-L231">source</a></section></article><h2 id="Optimizer-Module"><a class="docs-heading-anchor" href="#Optimizer-Module">Optimizer Module</a><a id="Optimizer-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizer-Module" title="Permalink"></a></h2><p>Functions for optimization. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Optimizer.levenberg_marquardt-Union{Tuple{T}, Tuple{Function, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T" href="#SummationByParts.Optimizer.levenberg_marquardt-Union{Tuple{T}, Tuple{Function, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Optimizer.levenberg_marquardt</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SummationByParts.levenberg_marquardt</strong></p><p>Levenberg-Marquardt Algorithm (LMA) </p><p><strong>Inputs</strong></p><ul><li><code>fun</code>: function to be optimized</li><li><code>cub</code>: cubature data</li><li><code>q</code>: the degree of the quadrature rule</li><li><code>mask</code>: a vector of the index of the parameters to be determined</li><li><code>np</code>: number of particles </li><li><code>xinit</code>: initial parameter guess</li><li><code>xL</code>: lower bound on the parameters </li><li><code>xR</code>: upper bound on the parameters </li><li><code>nu</code>: parameter controling exploration (spliting between Newton&#39;s and steepest decent methods)</li><li><code>maxiter</code>: maximum number of iterations </li><li><code>tol</code>: tolerance to stop iteration </li><li><code>verbose</code>: boolean to print results of iteration periodically</li></ul><p><strong>Outputs</strong></p><ul><li><code>fmin</code>: the optimized function value</li><li><code>v</code>: the minimizer (solution)</li><li><code>iter</code>: number of itrations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/optimizer.jl#L407-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Optimizer.pso-Union{Tuple{T}, Tuple{Function, Int64, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T" href="#SummationByParts.Optimizer.pso-Union{Tuple{T}, Tuple{Function, Int64, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T"><code>SummationByParts.Optimizer.pso</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SummationByParts.pso</strong></p><p>Particle Swarm Optimization (PSO) Algorithm</p><p><strong>Inputs</strong></p><ul><li><code>fun</code>: function to be optimized</li><li><code>ne</code>: number of parameters to be found</li><li><code>cub</code>: cubature data</li><li><code>q</code>: the degree of the quadrature rule</li><li><code>mask</code>: a vector of the index of the parameters to be determined</li><li><code>np</code>: number of particles </li><li><code>xinit</code>: initial parameter guess</li><li><code>xL</code>: lower bound on the parameters </li><li><code>xR</code>: upper bound on the parameters </li><li><code>delta1</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &lt;= 0.1</li><li><code>delta2</code>: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin &gt; 0.1</li><li><code>maxiter</code>: maximum number of iterations (default is 1000)</li><li><code>tol</code>: tolerance to stop iteration (default is 1e-14)</li><li><code>save_iter</code>: boolean to save results of each iteration</li><li><code>verbose</code>: boolean to print results of iteration periodically</li></ul><p><strong>Outputs</strong></p><ul><li><code>fmin</code>: the optimized function value</li><li><code>xmin</code>: the minimizer (solution)</li><li><code>f_all</code>: all function evaluations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/optimizer.jl#L180-L208">source</a></section></article><h2 id="OrthoPoly-Module"><a class="docs-heading-anchor" href="#OrthoPoly-Module">OrthoPoly Module</a><a id="OrthoPoly-Module-1"></a><a class="docs-heading-anchor-permalink" href="#OrthoPoly-Module" title="Permalink"></a></h2><p>Functions for working with orthogonal polynomials.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.diffjacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.diffjacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffjacobipoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.diffjacobipoly{T}</strong></p><p>Evaluate the first derivative of a Jacobi Polynomial at some points.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>: points at which to evaluate polynomial derivative</li><li><code>alpha</code>,<code>beta</code>: define the type of Jacobi Polynomial (alpha + beta != 1)</li><li><code>N</code>: polynomial degree</li></ul><p><strong>Outputs</strong></p><ul><li>dP - derivative of polynomial evaluated at x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L170-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffproriolpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.diffproriolpoly{T}</strong></p><p>Evaluate the derivatives of a Proriol orthogonal polynomial basis function on the right tetrahedron.</p><p><em>Notes</em>: the derivatives are computed using the complex-step method (since there  are many outputs and only 3 inputs); therefore, a different method should be  used for verification of this method.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>,<code>y</code>,<code>z</code>: locations at which to evaluate the derivative</li><li><code>i</code>,<code>j</code>,<code>k</code>: index triple that defines the basis function to differentiate; see Hesthaven and Warburton&#39;s Nodal DG book, for example, for a reference.</li></ul><p><strong>Outputs</strong></p><ul><li><code>dPdx</code>,<code>dPdy</code>,<code>dPdz</code>: derivatives of basis function at (<code>x</code>,<code>y</code>,<code>z</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L332-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.diffproriolpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.diffproriolpoly</strong></p><p>Evaluate the derivatives of a Proriol orthogonal polynomial basis function on the right triangle.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>,<code>y</code>: locations at which to evaluate the derivative</li><li><code>i</code>,<code>j</code>: index pair that defines the basis function to differentiate; see Hesthaven and Warburton&#39;s Nodal DG book, for example, for a reference.</li></ul><p><strong>Outputs</strong></p><ul><li><code>dPdx</code>,<code>dPdy</code>: derivative of basis function at (<code>x</code>,<code>y</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L280-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.jacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.jacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.jacobipoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.jacobipoly{T}</strong></p><p>Evaluate a Jacobi polynomial at some points.  Based on JacobiP in Hesthaven and Warburton&#39;s nodal DG book.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>: points at which to evaluate polynomial</li><li><code>alpha</code>,<code>beta</code>: define the type of Jacobi Polynomial (alpha + beta != 1)</li><li><code>N</code>: polynomial degree</li></ul><p><strong>Outputs</strong></p><ul><li><code>P</code>: the polynomial evaluated at x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.lglnodes" href="#SummationByParts.OrthoPoly.lglnodes"><code>SummationByParts.OrthoPoly.lglnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>OrthoPoly.lglnodes</strong></p><p>Computes the Legendre-Gauss-Lobatto (LGL) quadrature nodes and weights on the interval [-1,1].  The LGL nodes are the zeros of (1-x^2)*P&#39;<em>N(x), where P</em>N(x) denotes the Nth Legendre polynomial.</p><p><em>Reference</em>: C. Canuto, M. Y. Hussaini, A. Quarteroni, T. A. Tang, &quot;Spectral  Methods in Fluid Dynamics,&quot; Section 2.3. Springer-Verlag 1987</p><p><strong>Inputs</strong></p><ul><li><code>N</code>: highest degree (number of nodes = N+1)</li><li><code>T</code>: number type</li></ul><p><strong>Outputs</strong></p><ul><li><code>x</code>: the LGL nodes</li><li><code>w</code>: the LGL weights</li></ul><p>Julia version adapted from Matlab code written by Greg von Winckel - 04/17/2004 Contact: gregvw@chtm.unm.edu</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L23-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.lgnodes" href="#SummationByParts.OrthoPoly.lgnodes"><code>SummationByParts.OrthoPoly.lgnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>OrthoPoly.lgnodes</strong></p><p>Computes the Legendre-Gauss (LG) quadrature nodes and weights on the interval [-1,1].  The LG nodes are the zeros of P<em>N(x), where P</em>N(x) denotes the Nth Legendre polynomial.</p><p><strong>Inputs</strong></p><ul><li><code>N</code>: number of nodes</li><li><code>T</code>: number type</li></ul><p><strong>Outputs</strong></p><ul><li><code>x</code>: the LG nodes</li><li><code>w</code>: the LG weights</li></ul><p>Julia version adapted from Matlab code written by Greg von Winckel - 02/25/2004 Contact: gregvw@chtm.unm.edu</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L71-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.proriolpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.proriolpoly{T}: method for a right tetrahedron</strong></p><p>Evaluate Proriol orthogonal polynomial basis function on the right tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>,<code>y</code>,<code>z</code>: locations at which to evaluate the polynomial</li><li><code>i</code>,<code>j</code>,<code>k</code>: index triple that defines the basis function to evaluate; see Hesthaven and Warburton&#39;s Nodal DG book, for example, for a reference.</li></ul><p><strong>Outputs</strong></p><ul><li><code>P</code>: basis function at (<code>x</code>,<code>y</code>,<code>z</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number" href="#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T&lt;:Number"><code>SummationByParts.OrthoPoly.proriolpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.proriolpoly{T}: method for right triangle</strong></p><p>Evaluate Proriol orthogonal polynomial basis function on the right triangle.</p><p><strong>Inputs</strong></p><ul><li><code>x</code>,<code>y</code>: locations at which to evaluate the polynomial</li><li><code>i</code>,<code>j</code>: index pair that defines the basis function to evaluate; see Hesthaven and Warburton&#39;s Nodal DG book, for example, for a reference.</li></ul><p><strong>Outputs</strong></p><ul><li><code>P</code>: basis function at (<code>x</code>,<code>y</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L223-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde{T}</strong></p><p>Evaluate the Vandermonde matrix using the Proriol polynomials on the right tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>,<code>z</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>,<code>Vdy</code>,<code>Vdz</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>,<code>z</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L418-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde{T}</strong></p><p>Evaluate the Vandermonde matrix using the Proriol polynomials on the right triangle.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>,<code>Vdy</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L376-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_arnoldi{T}</strong></p><p>Evaluate the Vandermonde with Arnoldi on the right tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>,<code>z</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>,<code>Vdy</code>,<code>Vdz</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>,<code>z</code>)</li><li><code>Hes</code>: the Hessenberg matrix </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L813-L830">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_arnoldi{T}</strong></p><p>Evaluate the Vandermonde with Arnoldi on the right triangle.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>, <code>Vdy</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>)</li><li><code>Hes</code>: the Hessenberg matrix </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L683-L700">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_arnoldi</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_arnoldi{T}</strong></p><p>Evaluate the Vandermonde with Arnoldi on the line.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>: derivatives of the Vandermonde matrix at (<code>x</code>)</li><li><code>Hes</code>: the Hessenberg matrix </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L641-L658">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_full-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_full-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_full</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_full{T}</strong></p><p>Evaluate the Vandermonde and complements it with the nullspace to create a full rank matrix.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>: locations at which to evaluate the derivative</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vfull</code>: the full rank Vandermonde matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L930-L944">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_monomial{T}</strong></p><p>Evaluate the Vandermonde matrix using monomials on the right tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>,<code>z</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li><li><code>compute_integ</code>: indicates whether to compute the integral of the monomial basis functions</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>,<code>Vdy</code>, <code>Vdz</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>,<code>z</code>)</li><li><code>Vinteg</code>: the integral of each basis function in the Vandermonde matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L572-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_monomial{T}</strong></p><p>Evaluate the Vandermonde matrix using monomials on the right triangle.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>,<code>y</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li><li><code>compute_integ</code>: indicates whether to compute the integral of the monomial basis functions</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>,<code>Vdy</code>: derivatives of the Vandermonde matrix at (<code>x</code>,<code>y</code>)</li><li><code>Vinteg</code>: the integral of each basis function in the Vandermonde matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L511-L529">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T" href="#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T"><code>SummationByParts.OrthoPoly.vandermonde_monomial</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>OrthoPoly.vandermonde_monomial{T}</strong></p><p>Evaluate the Vandermonde matrix using monomials on the line.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the maximum total degree of the polynomial</li><li><code>x</code>: locations at which to evaluate the derivative</li><li><code>compute_grad</code>: indicates whether to compute the gradient of the Vandermonde matrix</li><li><code>compute_integ</code>: indicates whether to compute the integral of the monomial basis functions</li></ul><p><strong>Outputs</strong></p><ul><li><code>V</code>: the Vandermonde matrix </li><li><code>Vdx</code>: derivatives of the Vandermonde matrix at (<code>x</code>)</li><li><code>Vinteg</code>: the integral of each basis function in the Vandermonde matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/orthopoly.jl#L464-L482">source</a></section></article><h2 id="Outer-Constructors"><a class="docs-heading-anchor" href="#Outer-Constructors">Outer Constructors</a><a id="Outer-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Outer-Constructors" title="Permalink"></a></h2><p>Constructors for the SBP operator classes.</p><pre><code class="language-docs hljs">SummationByParts.getLineSegSBPLobbato
SummationByParts.getLineSegSBPLegendre
SummationByParts.getTriSBPGamma
SummationByParts.getTriSBPOmega
SummationByParts.getTriSBPDiagE
SummationByParts.getTetSBPGamma
SummationByParts.getTetSBPOmega
SummationByParts.getTetSBPDiagE
SummationByParts.getLineSegFace
SummationByParts.TriFace
SummationByParts.getTriFaceForDiagE
SummationByParts.TetFace
SummationByParts.getTetFaceForDiagE</code></pre><h2 id="SymCubatures-Module"><a class="docs-heading-anchor" href="#SymCubatures-Module">SymCubatures Module</a><a id="SymCubatures-Module-1"></a><a class="docs-heading-anchor-permalink" href="#SymCubatures-Module" title="Permalink"></a></h2><p>Types and methods for mapping between symmetry groups and nodes for cubatures. on various domains</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.LineSymCub" href="#SummationByParts.SymCubatures.LineSymCub"><code>SummationByParts.SymCubatures.LineSymCub</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.LineSymCub</strong></p><p>Defines a symmetric quadrature rule on the interval [-1,1].  Current choices are Legendre-Gauss-Lobatto (LGL) or Legendre-Gauss (LG) rules.</p><p><strong>Fields</strong></p><ul><li><code>numparams</code> : total number of nodal degrees of freedom</li><li><code>numweights</code> : total number of unique weights</li><li><code>numnodes</code> : total number of nodes</li><li><code>vertices</code> : if true, vertices (ends of interval) are in the set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numsym</code> : number of node sets in each symmetry group (2 for [-1,1])</li><li><code>params</code> : the actual values of the orbit nodal parameters</li><li><code>weights</code> : values of the unique weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L76-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.OperType" href="#SummationByParts.SymCubatures.OperType"><code>SummationByParts.SymCubatures.OperType</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.OperType</strong></p><p><code>OperType</code> is an abtract type that defines the type of SBP operators It has the subtypes Omega, Gamma, and DiagE. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.PointSymCub" href="#SummationByParts.SymCubatures.PointSymCub"><code>SummationByParts.SymCubatures.PointSymCub</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.PointSymCub</strong></p><p>Defines the trivial point cubature for uniformity across methods.</p><p><strong>Fields</strong></p><ul><li><code>numparams</code> : total number of nodal degrees of freedom</li><li><code>numweights</code> : total number of unique weights</li><li><code>numnodes</code> : total number of nodes</li><li><code>vertices</code> : if true, vertices (ends of interval) are in the set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numsym</code> : number of node sets in each symmetry group (0 for [1])</li><li><code>params</code> : the actual values of the orbit nodal parameters</li><li><code>weights</code> : values of the unique weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L30-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.SymCub" href="#SummationByParts.SymCubatures.SymCub"><code>SummationByParts.SymCubatures.SymCub</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.SymCub</strong></p><p><code>SymCub</code> is an parametric abstract type that defines cubatures for symmetric nodal distributions.  It is parameterized on <code>T</code> in order to allow for future implementations of arbitrary precision types.  The parameterization also permits the use of the complex-step method for verification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.TetSymCub" href="#SummationByParts.SymCubatures.TetSymCub"><code>SummationByParts.SymCubatures.TetSymCub</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.TetSymCub</strong></p><p>Used to define symmetric cubature rules on the tetrahedron.  The <code>params</code> array determines the position of the parameterized nodes, and the <code>weights</code> array determines the value of the weight for each symmetric orbit.  Note that boolean fields are used to activate some degenerate symmetry orbits.  For example, vertices are a special case of several of the orbits, and should be activated by setting vertices=true rather than relying on a specific value of a parameter.</p><p><strong>Fields</strong></p><ul><li><code>numparams</code> : total number of nodal degrees of freedom</li><li><code>numweights</code> : total number of unique weights</li><li><code>numnodes</code> : total number of nodes</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>facecentroid</code> : if true, face centroids are present in the set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numfaceS21</code> : number of S21 face orbits (same tri orbit on face)</li><li><code>numfaceS111</code> : number of S111 face orbits (same tri orbit on face)</li><li><code>numS31</code> : number of S31 orbits (vertex to opposite face)</li><li><code>numS22</code> : number of S22 orbits</li><li><code>numS211</code>: number of S211 orbits</li><li><code>numS1111</code>: number of S1111 orbits</li><li><code>numsym</code> : number of node sets in each symmetry group (5 groups for Tet)</li><li><code>params</code> : the actual values of the orbit nodal parameters</li><li><code>weights</code> : values of the unique weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L224-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.TriSymCub" href="#SummationByParts.SymCubatures.TriSymCub"><code>SummationByParts.SymCubatures.TriSymCub</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SymCubatures.TriSymCub</strong></p><p>Used to define symmetric cubature rules on the triangle.  The <code>params</code> array determines the position of the parameterized nodes, and the <code>weights</code> array determines the value of the weight for each symmetric orbit.  Note that boolean fields are used to activate some degenerate orbits.  For example, vertices are a special case of several of the orbits, and should be activated by setting vertices=true rather than relying on a specific value of a parameter.</p><p><strong>Fields</strong></p><ul><li><code>numparams</code> : total number of nodal degrees of freedom</li><li><code>numweights</code> : total number of unique weights</li><li><code>numnodes</code> : total number of nodes</li><li><code>vertices</code> : if true, vertices are present in the set of nodes</li><li><code>midedges</code> : if true, edge midpoints are present in set of nodes</li><li><code>centroid</code> : if true, centroid is present in set of nodes</li><li><code>numedge</code> : number of unique edge parameters</li><li><code>numS21</code> : number of S21 orbits (vertex to opposite face)</li><li><code>numS111</code> : number of S111 orbits</li><li><code>numsym</code> : number of node sets in each symmetry group (3 groups for Tri)</li><li><code>params</code> : the actual values of the orbit nodal parameters</li><li><code>weights</code> : values of the unique weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L138-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcjacobian-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}}} where T" href="#SummationByParts.SymCubatures.calcjacobian-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcjacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcjacobian</strong></p><p>Returns the Jacobian of the nodal coordinates and weights with respect to their parameters.  In other words, returns the block-rectangular matrix [Jcoords, 0; 0, Jweights], where Jcoords is the Jacobian of the coordinates, Jweights is the Jacobian of the weights, and the 0s indicate zero blocks of the appropriate size.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the cubature domain</li></ul><p><strong>Outputs</strong></p><ul><li><code>Jac</code>: Jacobian of the nodal coordinates and weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L2338-L2356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcjacobianofnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Matrix{T}}} where T" href="#SummationByParts.SymCubatures.calcjacobianofnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcjacobianofnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcjacobianofnodes</strong></p><p>Returns the Jacobian of the nodes with respect to the orbit parameters.</p><p><em>Notes</em>: Jac stores all the x-coordinate Jacobians first, then y (then z)</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices of the cubature domain</li></ul><p><strong>Outputs</strong></p><ul><li><code>Jac</code>: Jacobian of the mapping from node parameters to nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1738-L1754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcjacobianofweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.calcjacobianofweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.calcjacobianofweights</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcjacobianofweights</strong></p><p>Returns the Jacobian of the nodal weights with respect to the unique weights. The resulting Jacobian is a rectangular matrix of ones and zeros that indicates the mapping from the unique weights to the nodal weights.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Outputs</strong></p><ul><li><code>Jac</code>: Jacobian of the mapping from (unique) weights to nodal weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L2160-L2175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub, Matrix{T}}} where T" href="#SummationByParts.SymCubatures.calcnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub, Matrix{T}}} where T"><code>SummationByParts.SymCubatures.calcnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcnodes</strong></p><p>Use the orbital parameter values to compute a cubature&#39;s nodal coordinates.  The second dimension of the <code>vtx</code> array of vertices does not need to match the dimension as the cubature; for example, a line quadrature can be over a line in 1D, 2D, 3D or ND, and a triangle cubature can be in 2D, 3D, or ND, etc.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li><li><code>vtx</code>: vertices that define the domain</li></ul><p><strong>Outputs</strong></p><ul><li><code>x</code>: cubature&#39;s nodal coordinates (potentially in a subspace)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1287-L1304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.calcweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.calcweights</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcweights</strong></p><p>Map the unique cubature weights to the weights of all nodes.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Outputs</strong></p><ul><li><code>w</code>: cubature&#39;s weights at all nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1981-L1994">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.calcweights_symgroup-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Array{T}}} where T" href="#SummationByParts.SymCubatures.calcweights_symgroup-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.calcweights_symgroup</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.calcweights_symgroup</strong></p><p>Map the cubature weights of all nodes to the unique weights of their symmetry groups.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Outputs</strong></p><ul><li><code>w</code>: cubature&#39;s weights of the symmetry group</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L2452-L2465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.findleftperm!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T" href="#SummationByParts.SymCubatures.findleftperm!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T"><code>SummationByParts.SymCubatures.findleftperm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.findleftperm!</strong></p><p>For a matrix <code>A</code>, we are given a right permutation of the columns, <code>A[:,permR]</code>. This function attempts to find the left permultation of rows such that                       <code>A[permL,:] = A[:,permR]</code></p><p><strong>Inputs</strong></p><ul><li><code>A</code>: a rectangular matrix for which the left permutation is sought</li><li><code>permR</code>: the given right permutation of the columns</li></ul><p><strong>Outputs</strong></p><ul><li><code>permL</code>: the left permutation of the rows, if it exists</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the permutation exists, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L833-L853">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getInternalParamMask-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getInternalParamMask-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getInternalParamMask</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getInternalParamMask</strong></p><p>Returns the set of parameter indices corresponding to internal nodes; this is useful when finding cubature rules for which we wish to fix the boundary nodes and only allow the internal nodes to move.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Returns</strong></p><ul><li><code>mask</code>: integer array of parameter indices associated with internal nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L2377-L2392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getbndrynodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getbndrynodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getbndrynodeindices</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getbndrynodeindices</strong></p><p>Returns the indices of the nodes that lie on the boundary, in their natural order.  See getfacenodeindices for a method returns node indices for each face.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule whose boundary-node indices are sought</li></ul><p><strong>Outputs</strong></p><ul><li><code>bndryindices</code>: indicies of nodes that lie on boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L431-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getfacebasedpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getfacebasedpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacebasedpermutation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getfacebasedpermutation</strong></p><p>Returns a permutation of the volume nodes (or a subset of them) for each face, such that the same face operator can be applied to all faces.  This is useful for volume-to-face interpolation or differentiation.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule for which a face-based permutation is sought</li><li><code>faceonly</code>: if true, only face nodes are used in the permutation.</li></ul><p><strong>Outputs</strong></p><ul><li><code>perm</code>: permutation of the volume nodes for each face</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1141-L1157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getfacenodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getfacenodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacenodeindices</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getfacenodeindices</strong></p><p>Returns the indices of the nodes that lie on each face.  See getbndrynodeindices for a method that returns a single array of boundary nodes.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule whose boundary-node indices are sought</li></ul><p><strong>Outputs</strong></p><ul><li><code>bndryindices</code>: indicies of nodes that lie on boundary; there is a separate column of indices for each edge/face.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L702-L717">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getfacevertexindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getfacevertexindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getfacevertexindices</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getfacevertexindices</strong></p><p>Returns the indices of the vertices that make up each face.  This is useful when building nodes on a given face using Barycentric coordinates</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule whose face vertices are sought</li></ul><p><strong>Outputs</strong></p><ul><li><code>facevtx</code>: subarray <code>facevtx[:,f]</code> lists the vertices of face <code>f</code> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L671-L685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getinteriornodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getinteriornodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getinteriornodeindices</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getinteriornodeindices</strong></p><p>Returns the indices of the nodes that are strictly interior.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule whose interior-node indices are sought</li></ul><p><strong>Outputs</strong></p><ul><li><code>indices</code>: indicies of nodes that are strictly interior.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L547-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getneighbourpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getneighbourpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getneighbourpermutation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getneighbourpermutation</strong></p><p>At element interfaces, the cubature nodes of the common face will not match when natural ordering is provided.  This routine produces the permutation that makes the &#39;right&#39; element&#39;s nodes match the &#39;left&#39; element&#39;s nodes.  The permutation depends on the face dimension:</p><ul><li>For line segment faces, i.e. points, a trival permutation is returned</li><li>For triangle faces, i.e. line segments, there is only one possible orientation.</li><li>For tetrahedral faces, i.e. triangles, there are three orientations:</li></ul><ol><li>The &quot;1&quot; vertex from each element&#39;s face is coincident;</li><li>The &quot;1&quot; vertex from face 1 coincides with &quot;2&quot; vertex from face 2;</li><li>The &quot;1&quot; vertex from face 1 coincides with &quot;3&quot; vertex from face 2.</li></ol><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule for which the permutation is sought</li></ul><p><strong>Outputs</strong></p><ul><li><code>perm</code>: permutation of the interface nodes for each possible orientation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1204-L1228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getnumboundarynodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getnumboundarynodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getnumboundarynodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getnumboundarynodes</strong></p><p>Returns the number of (explicit) boundary nodes</p><p><em>Notes</em>: if the parameter value for an internal orbit is such that the corresponding node lies on the boundary, this node is <strong>NOT</strong> included in the boundary-node count returned.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Outputs</strong></p><ul><li><code>numboundary</code>: number of boundary nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L345-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getnumfacenodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T" href="#SummationByParts.SymCubatures.getnumfacenodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T"><code>SummationByParts.SymCubatures.getnumfacenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getnumfacenodes</strong></p><p>Returns the number of nodes on an individual face of the element.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: symmetric cubature rule</li></ul><p><strong>Outputs</strong></p><ul><li><code>numfacenodes</code>: number of nodes on a face</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L390-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.getpermutation-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Vector{Int64}}} where T" href="#SummationByParts.SymCubatures.getpermutation-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Vector{Int64}}} where T"><code>SummationByParts.SymCubatures.getpermutation</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.getpermutation</strong></p><p>Returns a permutation of the cubature nodes based on a reordering of the vertices from their canonical orientation.  That is, finds the node ordering such that the new nodes have the same order as the old nodes, but relative to <code>vtxperm</code>.  This is useful for face-based operations.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature rule for which the permutation is sought</li><li><code>vtxperm</code>: the permutation that is applied to the vertices</li></ul><p><strong>Outputs</strong></p><ul><li><code>perm</code>: permutation of the cubature nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L872-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.setparams!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T" href="#SummationByParts.SymCubatures.setparams!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.setparams!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.setparams!</strong></p><p>Sets the nodal parameters for any parameterized symmetry orbits in the cubature.</p><p><strong>Inputs</strong></p><ul><li><code>params</code>: parameter values</li></ul><p><strong>In/Outs</strong></p><ul><li><code>cub</code>: symmetric cubature rule whose nodal parameters are being updated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1249-L1262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SymCubatures.setweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T" href="#SummationByParts.SymCubatures.setweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T"><code>SummationByParts.SymCubatures.setweights!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>SymCubatures.setweights!</strong></p><p>Sets a cubature&#39;s (unique) weights.</p><p><strong>Inputs</strong></p><ul><li><code>weights</code>: cubature weights grouped by orbit</li></ul><p><strong>In/Outs</strong></p><ul><li><code>cub</code>: symmetric cubature rule whose weights are being updated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/symcubatures.jl#L1268-L1281">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>SBP abstract and concrete type definitions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.AbstractSBP" href="#SummationByParts.AbstractSBP"><code>SummationByParts.AbstractSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.AbstractSBP</strong></p><p><code>AbstractSBP</code> is a parametric abstract type that defines summation-by-parts finite-difference operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.LineSegSBP" href="#SummationByParts.LineSegSBP"><code>SummationByParts.LineSegSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.LineSegSBP</strong></p><p>Defines diagonal-norm SBP first-derivative operators on a line segment.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : maximum polynomial degree for which the derivatives are exact</li><li><code>numnodes</code> : number of nodes on line segment required for these operators</li><li><code>cub</code> : a symmetric cubature type for line segments (usually LG or LGL)</li><li><code>vtx</code> : vertices of the reference element in computational space</li><li><code>w</code> : cubature weights, i.e. the diagonal SBP norm, stored as an array</li><li><code>Q[:,:,1]</code> : discrete stiffness matrix operator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L12-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TriSBP" href="#SummationByParts.TriSBP"><code>SummationByParts.TriSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TriSBP</strong></p><p>Defines diagonal-norm SBP first-derivative operators on a right-triangle.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : maximum polynomial degree for which the derivatives are exact</li><li><code>numnodes</code> : number of nodes in the triangle required for these operators</li><li><code>cub</code> : a symmetric cubature type for triangles</li><li><code>vtx</code> : vertices of the reference element in computational space</li><li><code>w</code> : cubature weights, i.e. the diagonal SBP norm, stored as an array</li><li><code>Q[:,:,i]</code> : discrete stiffness matrix operator in ith coordinate direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SparseTriSBP" href="#SummationByParts.SparseTriSBP"><code>SummationByParts.SparseTriSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.SparseTriSBP</strong></p><p>Defines diagonal-norm SBP first-derivative operators on a right-triangle using a cubature rule that is greater than 2*p-1.  This provides additional flexiblity in the SBP operator that is used to make a sparse S.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : maximum polynomial degree for which the derivatives are exact</li><li><code>numnodes</code> : number of nodes in the triangle required for these operators</li><li><code>cub</code> : a symmetric cubature type for triangles</li><li><code>vtx</code> : vertices of the reference element in computational space</li><li><code>w</code> : cubature weights, i.e. the diagonal SBP norm, stored as an array</li><li><code>Q[:,:,i]</code> : discrete stiffness matrix operator in ith coordinate direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L83-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TetSBP" href="#SummationByParts.TetSBP"><code>SummationByParts.TetSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TetSBP</strong></p><p>Defines diagonal-norm SBP first-derivative operators on a right-tetrahedron.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : maximum polynomial degree for which the derivatives are exact</li><li><code>numnodes</code> : number of nodes in the tetrahedron required for these operators</li><li><code>cub</code> : a symmetric cubature type for tetrahedra</li><li><code>vtx</code> : vertices of the reference element in computational space</li><li><code>w</code> : cubature weights, i.e. the diagonal SBP norm, stored as an array</li><li><code>Q[:,:,i]</code> : discrete stiffness matrix operator in ith coordinate direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L123-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SparseTetSBP" href="#SummationByParts.SparseTetSBP"><code>SummationByParts.SparseTetSBP</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.SparseTetSBP</strong></p><p>Defines diagonal-norm SBP first-derivative operators on a right-tetrahedron using a cubature rule that is greater than 2*p-1.  This provides additional flexiblity in the SBP operator that is used to make a sparse S.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : maximum polynomial degree for which the derivatives are exact</li><li><code>numnodes</code> : number of nodes in the tetrahedron required for these operators</li><li><code>cub</code> : a symmetric cubature type for tetrahedra</li><li><code>vtx</code> : vertices of the reference element in computational space</li><li><code>w</code> : cubature weights, i.e. the diagonal SBP norm, stored as an array</li><li><code>Q[:,:,i]</code> : discrete stiffness matrix operator in ith coordinate direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L159-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.AbstractFace" href="#SummationByParts.AbstractFace"><code>SummationByParts.AbstractFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.AbstractFace</strong></p><p><code>AbstractFace</code> is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L199-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.DenseFace" href="#SummationByParts.DenseFace"><code>SummationByParts.DenseFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.DenseFace</strong></p><p><code>DenseFace</code> is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators.  This is a subtype for which interpolation is a dense matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L209-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.LineSegFace" href="#SummationByParts.LineSegFace"><code>SummationByParts.LineSegFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.LineSegFace</strong></p><p>Defines a &quot;face&quot; between two LineSegSBP operators with the same cubature nodes.</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : face integration is exact for polys of degree 2*<code>degree</code></li><li><code>numnodes</code> : number of cubature nodes (always 1)</li><li><code>stencilsize</code> : number of nodes in the reconstruction stencil</li><li><code>dstencilsize</code> : number of nodes in the derivative operator stencils</li><li><code>cub</code> : a symmetric cubature type for line-segment faces (i.e. points)</li><li><code>vtx</code> : the vertices of the face in reference space, [-1]</li><li><code>wface</code> : mass matrix (quadrature) for the face (always 1.0)</li><li><code>interp[:,:]</code> : volume-to-face-nodes reconstruction operator</li><li><code>perm[:,:]</code> : permutation for volume nodes so <code>interp</code> can be used on both sides</li><li><code>deriv[:,:]</code> : derivative operators for face-based coordinate system</li><li><code>dperm[:,:]</code> : permutation for volume nodes so <code>deriv</code> can be used on both sides</li><li><code>nbrperm[:,:]</code> : permutation for face nodes on neighbour element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L220-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TriFace" href="#SummationByParts.TriFace"><code>SummationByParts.TriFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TriFace</strong></p><p>Defines a face between two TriSBP operators with the same cubature nodes</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : face integration is exact for polys of degree 2*<code>degree</code></li><li><code>numnodes</code> : number of cubature nodes</li><li><code>stencilsize</code> : number of nodes in the reconstruction stencil</li><li><code>dstencilsize</code> : number of nodes in the derivative operator stencils</li><li><code>cub</code> : a symmetric cubature type for triangle faces (i.e. edges)</li><li><code>vtx</code> : the vertices of the face in reference space, [-1,1]</li><li><code>wface</code> : mass matrix (quadrature) for the face</li><li><code>interp[:,:]</code> : volume-to-face-nodes reconstruction operator</li><li><code>perm[:,:]</code> : permutation for volume nodes so <code>interp</code> can be used on all sides</li><li><code>deriv[:,:]</code> : derivative operators for face-based coordinate system</li><li><code>dperm[:,:]</code> : permutation for volume nodes so <code>deriv</code> can be used on all sides</li><li><code>nbrperm[:,:]</code> : permutation for face nodes on neighbour element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L274-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TetFace" href="#SummationByParts.TetFace"><code>SummationByParts.TetFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TetFace</strong></p><p>Defines a face between two TetSBP operators with the same cubature nodes</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : face integration is exact for polys of degree 2*<code>degree</code></li><li><code>numnodes</code> : number of cubature nodes</li><li><code>stencilsize</code> : number of nodes in the reconstruction stencil</li><li><code>dstencilsize</code> : number of nodes in the derivative operator stencils</li><li><code>cub</code> : a symmetric cubature type for tetrahedral faces (i.e. triangles)</li><li><code>vtx</code> : the vertices of the face in the reference space of the face</li><li><code>wface</code> : mass matrix (quadrature) for the face</li><li><code>interp[:,:]</code> : volume-to-face-nodes reconstruction operator</li><li><code>perm[:,:]</code> : permutation for volume nodes so <code>interp</code> can be used on all sides</li><li><code>deriv[:,:]</code> : derivative operators for face-based coordinate system</li><li><code>dperm[:,:]</code> : permutation for volume nodes so <code>deriv</code> can be used on all sides</li><li><code>nbrperm[:,:]</code> : permutation for face nodes on neighbour element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L327-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.SparseFace" href="#SummationByParts.SparseFace"><code>SummationByParts.SparseFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.SparseFace</strong></p><p><code>SparseFace</code> is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators in the case where the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L378-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TriSparseFace" href="#SummationByParts.TriSparseFace"><code>SummationByParts.TriSparseFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TriSparseFace</strong></p><p>Defines a face between two TriSBP operators with the same cubature nodes, in which the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : face integration is exact for polys of degree 2*<code>degree</code></li><li><code>numnodes</code> : number of cubature nodes</li><li><code>dstencilsize</code> : number of nodes in the derivative operator stencils</li><li><code>cub</code> : a symmetric cubature type for triangle faces (i.e. edges)</li><li><code>vtx</code> : the vertices of the face in reference space, [-1,1]</li><li><code>wface</code> : mass matrix (quadrature) for the face</li><li><code>perm[:,:]</code> : maps volume nodes to face nodes on each side</li><li><code>deriv[:,:]</code> : derivative operators for face-based coordinate system</li><li><code>dperm[:,:]</code> : permutation for volume nodes so <code>deriv</code> can be used on all sides</li><li><code>nbrperm[:,:]</code> : permutation for face nodes on neighbour element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L389-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.TetSparseFace" href="#SummationByParts.TetSparseFace"><code>SummationByParts.TetSparseFace</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>SBP.TetSparseFace</strong></p><p>Defines a face between two TetSBP operators with the same cubature nodes, in which the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).</p><p><strong>Fields</strong></p><ul><li><code>degree</code> : face integration is exact for polys of degree 2*<code>degree</code></li><li><code>numnodes</code> : number of cubature nodes</li><li><code>dstencilsize</code> : number of nodes in the derivative operator stencils</li><li><code>cub</code> : a symmetric cubature type for tetrahedral faces (i.e. triangles)</li><li><code>vtx</code> : the vertices of the face in the reference space of the face</li><li><code>wface</code> : mass matrix (quadrature) for the face</li><li><code>perm[:,:]</code> : permutation for volume nodes to face nodes on each side</li><li><code>deriv[:,:]</code> : derivative operators for face-based coordinate system</li><li><code>dperm[:,:]</code> : permutation for volume nodes so <code>deriv</code> can be used on all sides</li><li><code>nbrperm[:,:]</code> : permutation for face nodes on neighbour element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/sbp_types.jl#L439-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Boundary" href="#SummationByParts.Boundary"><code>SummationByParts.Boundary</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>ODLCommonTools.Boundary</strong></p><p>Used to identify boundary faces in a finite-element grid.</p><p><strong>Fields</strong></p><ul><li><code>element</code> : index of the element to which the boundary face belongs</li><li><code>face</code> : the face index of the boundary (local index to the element)</li></ul><p><strong>Example</strong></p><p>To mark face 2 of element 7 to be a boundary face, use <code>Boundary(7,2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/face_types.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.Interface" href="#SummationByParts.Interface"><code>SummationByParts.Interface</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>ODLCommonTools.Interface</strong></p><p>Used to identify interfaces between elements in a finite-element grid.</p><p><strong>Fields</strong></p><ul><li><code>elementL</code> : index of the so-called left element in the pair</li><li><code>elementR</code> : index of the so-called right element in the pair</li><li><code>faceL</code> : the face index of the interface with respect to the left element</li><li><code>faceR</code> : the face index of the interface with respect to the right element</li><li><code>orient</code> : orientation of the &#39;right&#39; element relative to the &#39;left&#39;</li></ul><p><strong>Example</strong></p><p>Consider an interface between elements 2 and 5.  Suppose the interface is on face 1 of element 2 and face 3 of element 5.  Furthermore, suppose element 5 has orientation 1 relative to element 1 (defintion of orientation TBD).  This can be indicated as <code>Interface(2,5,1,3,1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/face_types.jl#L24-L44">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><p>Functions that are not easily categorized.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.getNumFaceNodes" href="#SummationByParts.getNumFaceNodes"><code>SummationByParts.getNumFaceNodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.getNumFaceNodes</strong></p><p>Returns the number of SBP element nodes on a face.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator</li></ul><p><strong>Returns</strong></p><ul><li><code>numfacenodes</code>: number of nodes on (one) face of the element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.getnbrnodeindex" href="#SummationByParts.getnbrnodeindex"><code>SummationByParts.getnbrnodeindex</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.getnbrnodeindex</strong></p><p>Returns the face-node index on <code>face.faceR</code> equivalent to index <code>i</code> on <code>face.faceL</code>.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator</li><li><code>face</code>: an element interface</li><li><code>i</code>: face-node index on <code>face.faceL</code></li></ul><p><strong>Returns</strong></p><ul><li><code>j</code>: face-node index on <code>face.faceR</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L24-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcnodes" href="#SummationByParts.calcnodes"><code>SummationByParts.calcnodes</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcnodes</strong></p><p>This function returns the node coordinates for an SBP operator.  It basically calls calcnodes for the underlying SymCubature.  This function assumes the element mapping is linear, i.e. edges are lines.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator</li><li><code>vtx</code>: the vertices that define the element</li></ul><p><strong>Outputs</strong></p><ul><li><code>x</code>: the node coordinates; 1st dimension is the coordinate, the second the node</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">  # define a third-order accurate SBP on triangles
  sbp = TriSBP{Float64}(degree=2)
  # build a simple 2-element grid on a square domain
  x = zeros(Float64, (2,sbp.numnodes,2))
  vtx = [0. 0.; 1. 0.; 0. 1.]
  x[:,:,1] = calcnodes(sbp, vtx)
  vtx = [1. 0.; 1. 1.; 0. 1.]
  x[:,:,2] = calcnodes(sbp, vtx)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L45-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcminnodedistance" href="#SummationByParts.calcminnodedistance"><code>SummationByParts.calcminnodedistance</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcminnodedistance</strong></p><p>Returns the minimum distance between distinct nodes on an element with straight sides</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator</li><li><code>vtx</code>: the vertices that define the element</li></ul><p><strong>Returns</strong></p><ul><li><code>mindist</code>: the minimum distance between distinct nodes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L77-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.buildinterpolation" href="#SummationByParts.buildinterpolation"><code>SummationByParts.buildinterpolation</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.buildinterpolation</strong></p><p>Builds a matrix operator that can reconstruct a field located at the sbp nodes to an auxlliary set of nodes.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBP operator</li><li><code>xinterp</code>: points to interpolate to in ref coords, size = [ndim,numpoints]</li><li><code>d=sbp.degree</code>: (optional) interpolation is exact for degree d polys</li></ul><p><strong>Returns</strong></p><ul><li><code>R</code>: the interpolation operator, size = [numpoints, sbp.numnodes]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L125-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.permuteinterface!" href="#SummationByParts.permuteinterface!"><code>SummationByParts.permuteinterface!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.permuteinterface!</strong></p><p>For a given array of values on a faces, permutes the node values (in place) to  be in the orientation specified by the orient field of the corresponding  Interface.  Methods are available for scalar and vector fields.</p><p><strong>Inputs</strong></p><ul><li><code>sbp</code>: an SBPFace operator</li><li><code>ifaces</code>: an array of Interfaces</li></ul><p><strong>In/Outs</strong></p><ul><li><code>uface</code>: the array of face values, must have dimensions          [n x sbpface.numnodes x length(ifaces] if 3D array (where n          is arbitrary) or [sbpface.numnodes x length(ifaces] if 2D.            The permutation is applied to the second array dimension for the           3D case or the first dimension in the 2D case.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L209-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.permuteface!" href="#SummationByParts.permuteface!"><code>SummationByParts.permuteface!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.permuteface!</strong></p><p>This function applys a permutation to the data on a particular face.</p><p><strong>Inputs</strong></p><ul><li><code>permvec</code>: vector specifying the permutation to apply</li><li><code>workarr</code>: a temporary array, same size as face_data, that is overwritten            during the computation</li></ul><p><strong>In/Outs</strong></p><ul><li><code>face_data</code>: an N-D array containing the data to be pemuted, where the             permutation is applied to the second dimension of the array             for N=2 and the first dimension if N=1.  N &gt; 2 is not             currently supported</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L269-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.basispursuit!" href="#SummationByParts.basispursuit!"><code>SummationByParts.basispursuit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.basispursuit!</strong></p><p>Finds an approximate solution to the underdetermined problem <code>Ax = b</code> that is sparse using the alternating direction method of multipliers (ADMM).</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: matrix in the linear equation that must be satisfied</li><li><code>b</code>: vector in the linear equation that must be satisfied</li><li><code>rho</code> (optional) : augmented Lagrangian parameter</li><li><code>alpha</code> (optional) : over-relaxation parameter (usually between 1.0 and 1.8)</li><li><code>hist</code> (optional): output the convergence history to the terminal</li><li><code>abstol</code> (optional): absolute tolerance</li><li><code>reltol</code> (optional): relative tolerance</li></ul><p><strong>In/Outs</strong></p><ul><li><code>x</code>: sparse solution of the problem</li></ul><p><strong>Notes</strong></p><p>This is a direct translation of Boyd et al&#39;s Matlab implementation of ADMM for basis pursuit.  This method is not well suited to high-accuracy solutions, so, for our purposes, it is best used as a means of identifying the sparsity pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L322-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcSparseSolution!" href="#SummationByParts.calcSparseSolution!"><code>SummationByParts.calcSparseSolution!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcSparseSolution!</strong></p><p>Finds a solution to the underdetermined problem <code>Ax = b</code> that is sparse.  Uses basispursit! to find an approximate solution, which is used to eliminate columns from <code>A</code>, from which an accurate solution is found.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: matrix in the linear equation that must be satisfied</li><li><code>b</code>: vector in the linear equation that must be satisfied</li></ul><p><strong>In/Outs</strong></p><ul><li><code>x</code>: sparse solution of the problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L414-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.absMatrix!" href="#SummationByParts.absMatrix!"><code>SummationByParts.absMatrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.absMatrix!</strong></p><p>Computes the absolulte value of a symmetric matrix <code>A</code>; that is, using the eigenvalue factorization <code>A</code> = E<em>Λ</em>E^T, this function returns <code>Aabs</code> = E<em>|Λ|</em>E^T, where |Λ| is the elementwise absolute value applied to the diagonal eigenvalue matrix.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: symmetric matrix whose absolute value is sought</li></ul><p><strong>In/Outs</strong></p><ul><li><code>Aabs</code>: matrix where the absolute value is stored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L455-L471">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcMatrixEigs!" href="#SummationByParts.calcMatrixEigs!"><code>SummationByParts.calcMatrixEigs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcMatrixEigs!</strong></p><p>Finds the eigenvalues of the given matrix in order of increasing modulus; that is, this works for symmetric and non-symmetric square matrices.  This method is basically a front end for <code>eigfact</code>.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: matrix whose eigenvalues are desired</li></ul><p><strong>In/Outs</strong></p><ul><li><code>λ</code>: eigenvalues of <code>A</code> sorted in increasing modulus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L510-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.calcMatrixEigs_rev!" href="#SummationByParts.calcMatrixEigs_rev!"><code>SummationByParts.calcMatrixEigs_rev!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.calcMatrixEigs_rev!</strong></p><p>The reverse-mode differentiated version of <code>calcMatrixEigs!</code>.  The math behind this is from Mike Giles report &quot;An extended collection of matrix derivative results for forward and reverse mode algorithmic differentiation.&quot;</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: matrix whose eigenvalues are desired</li><li><code>λ_bar</code>: ∂f/∂λ vector that multiplies derivatives from left</li></ul><p><strong>In/Outs</strong></p><ul><li><code>λ</code>: eigenvalues of <code>A</code> sorted in increasing modulus</li><li><code>A_bar</code>: derivatives ∂f/∂A</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L539-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.conditionObj" href="#SummationByParts.conditionObj"><code>SummationByParts.conditionObj</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.conditionObj</strong></p><p>Let <code>x</code> = <code>Znull</code>*<code>xred</code> + <code>xperp</code> be the (unique) entries in a skew symmetric matrix <code>S</code>, and let <code>E</code> be a symmetric positive-definite matrix.  This routine computes an approximation of the condition number of the matrix <code>A</code> = (<code>S</code> + <code>E</code>).  The matrix <code>A</code> corresponds to a weak-form discretization of linear advection.  The condition number is approximated using KS aggregation to ensure the objective is differentiable.</p><p><strong>Inputs</strong></p><ul><li><code>xred</code>: a reduced-space for the entries in the skew-symmetric matrix</li><li><code>p</code>: defines the KS parameter; as p tends to infinity, we get obj = kappa(A)</li><li><code>xperp</code>: a particular solution that satisfies the SBP accuracy conditions</li><li><code>Znull</code>: matrix that defines the null-space of the SBP accuracy conditions</li><li><code>E</code>: symmetric positive-definite matrix (boundary operator for an SBP matrix)</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: approximate condition number of <code>A</code> as defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L573-L595">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.conditionObjGrad!" href="#SummationByParts.conditionObjGrad!"><code>SummationByParts.conditionObjGrad!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.conditionObjGrad!</strong></p><p>Computes the gradient of the function <code>conditionObj</code> with respect to <code>xred</code>, and returns it in the array <code>g</code>.</p><p><strong>Inputs</strong></p><ul><li><code>xred</code>: a reduced-space for the entries in the skew-symmetric matrix</li><li><code>p</code>: defines the KS parameter; as p tends to infinity, we get obj = kappa(A)</li><li><code>xperp</code>: a particular solution that satisfies the SBP accuracy conditions</li><li><code>Znull</code>: matrix that defines the null-space of the SBP accuracy conditions</li><li><code>E</code>: symmetric positive-definite matrix (boundary operator for an SBP matrix)</li></ul><p><strong>In/Outs</strong></p><ul><li><code>g</code>: gradient of the objective <code>conditionObj</code> with respect to <code>xred</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L632-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.eigenvalueObj" href="#SummationByParts.eigenvalueObj"><code>SummationByParts.eigenvalueObj</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.eigenvalueObj</strong></p><p>Let <code>x</code> = <code>Znull</code><em><code>xred</code> + <code>xperp</code> be the (unique) entries in a skew symmetric matrix <code>S</code>, and let <code>E</code> be a symmetric matrix.  This routine returns the spectral radius of the matrix <code>A</code> = diagm(1./<code>w</code>)</em>(<code>S</code> + |<code>E</code>|), where |⋅| is the elementwise absolute value.  The matrix <code>A</code> corresponds to a strong-form discretization of linear advection.</p><p><strong>Inputs</strong></p><ul><li><code>xred</code>: a reduced-space for the entries in the skew-symmetric matrix</li><li><code>p</code>: not used presently</li><li><code>xperp</code>: a particular solution that satisfies the SBP accuracy conditions</li><li><code>Znull</code>: matrix that defines the null-space of the SBP accuracy conditions</li><li><code>w</code>: diagonal norm entries in an SBP operator</li><li><code>E</code>: symmetric matrix, usually the boundary operator for an SBP matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: the 2p-norm of the moduli of the eigenvalues of <code>A</code> as defined above.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L818-L840">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.eigenvalueObjGrad!" href="#SummationByParts.eigenvalueObjGrad!"><code>SummationByParts.eigenvalueObjGrad!</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.eigenvalueObjGrad!</strong></p><p>Computes the gradient of the function <code>eigenvalueObj</code> with respect to <code>xred</code>, and returns it in the array <code>g</code>.</p><p><strong>Inputs</strong></p><ul><li><code>xred</code>: a reduced-space for the entries in the skew-symmetric matrix</li><li><code>p</code>: not used at present</li><li><code>xperp</code>: a particular solution that satisfies the SBP accuracy conditions</li><li><code>Znull</code>: matrix that defines the null-space of the SBP accuracy conditions</li><li><code>w</code>: diagonal norm entries in an SBP operator</li><li><code>E</code>: symmetric matrix, usually the boundary operator for an SBP matrix</li></ul><p><strong>In/Outs</strong></p><ul><li><code>g</code>: gradient of the objective <code>eigenvalueObj</code> with respect to <code>xred</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L878-L897">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.truncErr" href="#SummationByParts.truncErr"><code>SummationByParts.truncErr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.truncErr</strong></p><p>This function computes the truncation error from the derivative operator.</p><p><strong>Inputs</strong></p><ul><li><code>d</code>: the degree of the operator</li><li><code>x</code>: the coordinates of the quadrature points</li><li><code>w</code>: the weights of the quadrature rule</li><li><code>Q</code>: the weak differentiation matrices</li></ul><p><strong>In/Outs</strong></p><ul><li><code>trunc_err</code>: the truncation error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L960-L974">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.computeConditionNumber" href="#SummationByParts.computeConditionNumber"><code>SummationByParts.computeConditionNumber</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.computeConditionNumber</strong></p><p>This function computes the condition number of A=S+E for operators on triangular elements.</p><p><strong>Inputs</strong></p><ul><li><code>p</code>: the degree of the operator</li><li><code>opertype</code>: the SBP operator family type</li><li><code>vtx</code>: the vertices of the </li><li><code>vertices</code>: indicates whether vertices are included</li></ul><p><strong>In/Outs</strong></p><ul><li><code>condA</code>: the condition number of A=S+E</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L1012-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.pocs_sparse_s" href="#SummationByParts.pocs_sparse_s"><code>SummationByParts.pocs_sparse_s</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.pocs<em>sparse</em>s</strong></p><p>This function uses the Projection Onto Convex Sets (POCS) algorithm to construct a sparse skew-symmetric S matrix.</p><p><strong>Inputs</strong></p><ul><li><code>S</code>: the skew-symmetric matrix</li><li><code>H</code>: the norm/mass matrix</li><li><code>E</code>: the boundary integration matrix</li><li><code>V</code>: the Vandermonde matrix</li><li><code>Vdx</code>: the gradient of the Vandermonde matrix</li></ul><p><strong>In/Outs</strong></p><ul><li><code>S</code>: the sparsified skew-symmetric matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L1054-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.quadTruncErr" href="#SummationByParts.quadTruncErr"><code>SummationByParts.quadTruncErr</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.quadTruncErr</strong></p><p>This function computes the integration truncation error of the quadrature rule on the right triangle or tetrahedron.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>q</code>: the quadarature degree</li></ul><p><strong>In/Outs</strong></p><ul><li><code>quadTruncErr</code>: the quadature truncation error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L1109-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SummationByParts.checkInteriorNodeLocaton" href="#SummationByParts.checkInteriorNodeLocaton"><code>SummationByParts.checkInteriorNodeLocaton</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>SummationByParts.checkInteriorNodeLocaton</strong></p><p>This function checks if all interior nodes are within the interior of the right triangle or tetrahedron; i.e., not outside or on the boundaries.</p><p><strong>Inputs</strong></p><ul><li><code>cub</code>: a symmetric cubature for the right triangle</li><li><code>vtx</code>: the vertices of the triangle</li></ul><p><strong>Note</strong>: The vertex is assumed to be on [-1,1] interval in each dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/OptimalDesignLab/SummationByParts.jl/blob/8a7c2d83cc6c8b2fc940aa714eed1208f2f64d54/src/utils.jl#L1159-L1172">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 16:09">Tuesday 9 July 2024</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
