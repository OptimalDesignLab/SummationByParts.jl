var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Build-Operators","page":"Reference","title":"Build Operators","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions used to build the SBP operators.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# buildoperators.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.bndrynodalexpansion\nSummationByParts.nodalexpansion\nSummationByParts.boundaryoperators\nSummationByParts.boundarymassmatrix\nSummationByParts.accuracyconstraints\nSummationByParts.commuteerror\nSummationByParts.buildoperators\nSummationByParts.buildsparseoperators\nSummationByParts.buildMinConditionOperators\nSummationByParts.getnodepermutation\nSummationByParts.buildoperators_pocs","category":"page"},{"location":"reference/#SummationByParts.bndrynodalexpansion","page":"Reference","title":"SummationByParts.bndrynodalexpansion","text":"SummationByParts.bndrynodalexpansion\n\nComputes the transformation matrix that maps the Proriol orthogonal polynomials to polynomials that are nodal on the boundary nodes, i.e. if E is the transformation matrix and P is the matrix of Proriol polys, with the polynomials listed by row, then P*E = I, when restricted to the boundary nodes.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nOutputs\n\nE: transformation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.nodalexpansion","page":"Reference","title":"SummationByParts.nodalexpansion","text":"SummationByParts.nodalexpansion\n\nComputes the transformation matrix that maps the Proriol orthogonal polynomials to polynomials that are nodal on the cubature nodes, i.e. if C is the transformation matrix and P is the matrix of Proriol polys, with the polynomials listed by row, then P*C = I, when restricted to the nodes.  This function can be used to construct the operators in the spectral-element method of Giraldo and Tayler.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree on the edges\ne: maximum degree of bubble functions on the interior\n\nOutputs\n\nC: transformation matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundaryoperators","page":"Reference","title":"SummationByParts.boundaryoperators","text":"SummationByParts.boundaryoperators\n\nFinds the symmetric part of the SBP operators, Ex, Ey (Ez).  These operators coorespond to boundary integrals in the divergence theorem, and are related to the mass matrices of the boundary faces.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nOutputs\n\nEx, Ey (Ez): symmetric parts of the SBP first derivative operators\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundarymassmatrix","page":"Reference","title":"SummationByParts.boundarymassmatrix","text":"SummationByParts.boundarymassmatrix\n\nReturns the (dense) mass matrix for a set of nodes on a reference boundary. This mass matrix can be used for boundary integration or to impose boundary conditions weakly.  The array bndryindices is also returned, which is a list of element-node indices for each boundary (see also SymCubatures.getfacenodeindices).\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the polynomials\n\nOutputs\n\nHbndry: reference boundary mass matrix\nbndryindices: list of nodes that lie on each boundary\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.accuracyconstraints","page":"Reference","title":"SummationByParts.accuracyconstraints","text":"SummationByParts.accuracyconstraints\n\nReturns the accuracy constraints on the asymmetric part of the SBP stiffness matrices.  These constraints are linear, and for each coordinate-direction operator (i.e. Qx, Qy,...) the system matrix A is the same; only the right-hand side changes.\n\nThe columns in A are ordered assuming only the strictly lower triangular part of the operators are the unknowns.  These unknowns are ordered by row and then column.  For example, entry Q21 = -Q12 is the number 1 variable, and Q32 = -Q23 is the number 3 variable.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\nE: the symmetric part of the SBP stiffness matrices\ndl: (optional) the minimum total degree for the Proriol polynomials\n\nOutputs\n\nA: the system matrix for the linear accuracy constraints\nbx,by (bz): the right-hand-sides of the accuracy constraints\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.commuteerror","page":"Reference","title":"SummationByParts.commuteerror","text":"SummationByParts.commuteerror\n\nReturns the commute-error objective value.  For 2D SBP operators, this is defined as ||H(DxDy - DyDx)||^2, where the norm is the Frobenius norm.  For 3D operators, the error is defined as ||H(DxDy - DyDx)||^2 + ||H(DxDz - DzDx)||^2 + ||H(DyDz - DzDx||^2.\n\nInputs\n\nw: cubature rule weights\nQxpart,Qypart (Qzpart): Q operators that satisfy the accuracy conditions\nZ: basis for the null space of the accuracy constraints (may be empty)\nreducedsol: the weights for Z; the first [1:numnodes] elements are for Qx\n\nOutputs\n\nf: commute-error objective value\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildoperators","page":"Reference","title":"SummationByParts.buildoperators","text":"SummationByParts.buildoperators\n\nConstruct and return the SBP matrix operators, specifically the diagonal norm matrix and the stiffness matrices.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nOutputs\n\nw: the diagonal norm stored as a 1D array\nQ: the stiffness matrices\n\n\n\n\n\nNote: when a fifth input is included, it is interpreted as the degree of the   interior bubble functions, and the Q operators returned are the   spectral-element differentiation operators of Giraldo and Taylor\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildsparseoperators","page":"Reference","title":"SummationByParts.buildsparseoperators","text":"SummationByParts.buildsparseoperators\n\nConstruct and return sparse SBP matrix operators, specifically the diagonal norm matrix and the stiffness matrices.  These are sparse in the sense that there are zeros in the S matrices, but they are not returned as sparse matrices.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nOutputs\n\nw: the diagonal norm stored as a 1D array\nQ: the stiffness matrices\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildMinConditionOperators","page":"Reference","title":"SummationByParts.buildMinConditionOperators","text":"SummationByParts.buildMinConditionOperators\n\nConstruct and return SBP matrix operators that minimize the condition number of a model advection problem.  These operators have diagonal mass and boundary operators.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\ntol: (optional) gradient norm tolerance for the optimization problem\nvertices: (optional) if true, include vertices in the operator\nopthist: (optional) if true, show the optimization history\n\nOutputs\n\nw: the diagonal norm stored as a 1D array\nQ: the stiffness matrices\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getnodepermutation","page":"Reference","title":"SummationByParts.getnodepermutation","text":"SummationByParts.getnodepermutation\n\nThe node ordering produced by SymCubature is not convenient for mapping local to global node indices in the global residual assembly procedure.  This function returns a reordering that is more suited for local-to-global mapping.\n\nNote: the edge parameters of cub are assumed to be less than 0.5.\n\nWARNING: the faceperm array has not been thoroughly tested\n\nInputs\n\ncub: symmetric cubature rule\nd: maximum polynomial degree for which the SBP operator is exact\n\nOutputs\n\nperm: a permutation vector of indices\nfaceperm: a permutation vector for the face indices\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildoperators_pocs","page":"Reference","title":"SummationByParts.buildoperators_pocs","text":"SummationByParts.buildoperators_pocs\n\nConstruct SBP operators using the Projection Onto Convex Sets (POCS) algorithm \n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\nvertices: (optional) if true, include vertices in the operator\n\nOutputs\n\nD: the derivative matrices\nH: the norm/mass matrix\nE: the boundary integration matrices\nQ: the stiffness matrices\nS: the skew-symmetric matrices\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# buildfaceoperators.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.buildfacereconstruction\nSummationByParts.buildfacederivatives","category":"page"},{"location":"reference/#SummationByParts.buildfacereconstruction","page":"Reference","title":"SummationByParts.buildfacereconstruction","text":"SummationByParts.buildfacereconstruction\n\nBuilds a matrix operator that can reconstruct a field from a set of volume nodes to a set of face nodes.  The reconstruction operator is only constructed for one face, but a permutation array is returned that allows the same operator to be applied on all the faces.\n\nInputs\n\nfacecub: symmetric cubature rule for the face\ncub: symmetric cubature rule for the volume\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nReturns\n\nR: the volume- to face-node reconstruction operator\nperm: a permutation array that allows R to be applied on all faces\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildfacederivatives","page":"Reference","title":"SummationByParts.buildfacederivatives","text":"SummationByParts.buildfacederivatives\n\nBuilds matrix operators that can differentiate a polynomial field of degree d from a set of volume nodes to a set of face nodes.  The derivative operators are only constructed for one face, but a permutation array is returned that allows the same operators to be applied on all the faces.\n\nNote: the derivative operators are for the tangential and normal directions,   and do not necessarily correspond to the directions ξ and η (and ζ) used for   the volume derivatives.  These face derivatives are intended for edge   stabilization.\n\nInputs\n\nfacecub: symmetric cubature rule for the face\ncub: symmetric cubature rule for the volume\nvtx: vertices of the right simplex\nd: maximum total degree for the Proriol polynomials\n\nReturns\n\nD: derivative operators in [face node, vol node, direction] format\nperm: a permutation array that allows D to be applied on all faces\n\n\n\n\n\n","category":"function"},{"location":"reference/#Cubature-Module","page":"Reference","title":"Cubature Module","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Funtions for constructing cubature rules.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# cubature.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SummationByParts.Cubature]","category":"page"},{"location":"reference/#SummationByParts.Cubature.cubatureresidual-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.LineSymCub{T}, Int64}} where T","page":"Reference","title":"SummationByParts.Cubature.cubatureresidual","text":"Cubature.cubatureresidual\n\nThis method computes the residuals, F, between a cubature, defined by cub, and the true value of an integral.  Each residual corresponds with an orthogonal polynomial on the simplex up to degree q.  The Jacobian, dF, of the residual, with respect to the quadrature nodes and weights, is also returned.\n\nInputs\n\ncub: defines the nodes and weights of the cubature via symmetry orbits\nq: maximum degree of the othogonal polynomials used in the conditions\ncalc_grad: indicates whether to calculate the gradients the orthogonal polynomials\n\nOutputs\n\nF: the accuracy conditions for orthogonal polynomials up to degree q\ndF: derivative of F with respect to x, y, (z,) w, in that order\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.Cubature.equivalenceconstant-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}, Int64}} where T","page":"Reference","title":"SummationByParts.Cubature.equivalenceconstant","text":"Cubature.equivalenceconstant{T}\n\nComputes the equivalence constant for a given cubature; that is, it finds the maximum eigenvalue for the matrix pk^T H pm, where H = diag(weights) and pk denotes the orthogonal polynomial evaluated at the cubature points.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the right simplex\nq: maximum degree of polynomial for which the cubature is to be tested\n\nOutputs\n\nλmax: maximum eigenvalue, which is the equivalence constant\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.Cubature.getTetCubatureDiagE","page":"Reference","title":"SummationByParts.Cubature.getTetCubatureDiagE","text":"Cubature.getTetCubatureDiagE{T}\n\nReturns a cubature rule and vertices for the SBP DiagE operators on tetrahedra; these are cubatures that have nodes on the boundary that are analogous to LG or LGL quadrature rules, which then leads to diagonal E.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\nfaceopertype: the operator type on the facets of the tetrahedron\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right tetrahedron\nvtx: vertices for the right tetrahedron\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTetCubatureGamma","page":"Reference","title":"SummationByParts.Cubature.getTetCubatureGamma","text":"Cubature.getTetCubatureGamma{T}\n\nReturns a cubature rule and vertices for the SBP Gamma operators on tetrahedra; these are operators with (p+1)(p+2)/2 nodes on each face, where, typically, p = (q+1)/2.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right tetrahedron\nvtx: vertices for the right tetrahedron\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTetCubatureOmega","page":"Reference","title":"SummationByParts.Cubature.getTetCubatureOmega","text":"Cubature.getTetCubatureOmega{T}\n\nReturns a cubature rule and vertices for the SBP Omega operators on tetrahedra; these are cubatures that are analogous to Gauss-Legendre in 1D, and they are strictly internal to the tet. \n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right tetrahedron\nvtx: vertices for the right tetrahedron\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureDiagE","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureDiagE","text":"Cubature.getTriCubatureDiagE{T}\n\nReturns a cubature rule and vertices for the SBP DiagE operators on triangles; these are cubatures that have nodes on the boundary that correspond with LG or LGL quadrature rules, which then leads to diagonal E.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\nvertices: if true then vertices are included\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureDiagELineLGL","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureDiagELineLGL","text":"Cubature.getTriCubatureDiagELineLGL{T}\n\nReturns a cubature rule and vertices for the Line-LGL SBP DiagE operators  on triangles; these are cubatures that have nodes on the boundary that  correspond with LGL quadrature rules, which then leads to diagonal E.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureForTetFaceDiagE","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureForTetFaceDiagE","text":"Cubature.getTriCubatureDiagE{T}\n\nReturns a cubature rule and vertices for facets of the SBP DiagE operators  on tetrahedra; these should not be used for 2D problems as they do not  satisfy the accruacy requirements along their edge.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\nfaceopertype: the operator type on the facets of the tetrahedron\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureGamma","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureGamma","text":"Cubature.getTriCubatureGamma{T}\n\nReturns a cubature rule and vertices for the SBP Gamma operators on triangles; these are operators with p+1 nodes on each face, where, typically, p = (q+1)/2.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureOmega","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureOmega","text":"Cubature.getTriCubatureOmega{T}\n\nReturns a cubature rule and vertices for the SBP Omega operators on triangles; these are cubatures that are analogous to Gauss-Legendre in 1D, and they are strictly internal to the triangle. \n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureOmegaLG","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureOmegaLG","text":"Cubature.getTriCubatureOmegaLG{T}\n\nReturns a cubature rule and vertices for the SBP Omega operators  on triangles; these are cubatures derived by eliminating nodes in  the line-LG cubature.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.getTriCubatureOmegaLineLG","page":"Reference","title":"SummationByParts.Cubature.getTriCubatureOmegaLineLG","text":"Cubature.getTriCubatureOmegaLineLG{T}\n\nReturns a cubature rule and vertices for the SBP Omega operators  on triangles; these are cubatures derived by using tensor-product of half of the nodes in the LG quadrature rules.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.pointCubature","page":"Reference","title":"SummationByParts.Cubature.pointCubature","text":"Cubature.pointCubature\n\nThis returns a (trivial) point cubature and default vertex -1\n\nInputs\n\nT: the data type used to represent the cubature\n\nOutputs\n\ncub: a symmetric cubature for point\nvtx: vertex, [-1]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.quadrature","page":"Reference","title":"SummationByParts.Cubature.quadrature","text":"Cubature.quadrature{T}\n\nThis high-level function computes and returns a symmetric cubature of requested accuracy on the interval [-1,1]\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ninternal: if true, all nodes are strictly internal (default false)\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the interval [-1,1]\nvtx: vertices, [-1,1]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.quadratureUniform","page":"Reference","title":"SummationByParts.Cubature.quadratureUniform","text":"Cubature.quadratureUniform{T}\n\nThis high-level function computes and returns a uniform cubature of requested accuracy on the interval [-1,1]\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nN: number of nodes (N >= q+1)\nT: the data type used to represent the cubature\n\nOutputs\n\ncub: a symmetric cubature for the interval [-1,1]\nvtx: vertices, [-1,1]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.solvecubature!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T","page":"Reference","title":"SummationByParts.Cubature.solvecubature!","text":"Cubature.solvecubature!{SymCub{T}}\n\nAttempts to solve for the nodes and weights of a cubature that is exact for polynomials of degree r <= q.  The nodes and weights of the cubature are defined by cub, which is a parametric abstract type (see symcubatures.jl).\n\nInputs\n\ncub: symmetric cubature rule\nq: maximum (desired) degree for which the cubature is exact\nmask: array of indicies of parameters and weights that are free\ntol: tolerance with which to solve the accuracy conditions\nhist: if true, print the residual-norm convergence history\nxinit: initial parameter guess\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\n\nIn/Outs\n\ncub: on entry, defines the initial guess for the cubature nodes and weights. on exit, defines the nodes and weights that satisfy the desired accuracy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.Cubature.solvecubatureweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Int64}} where T","page":"Reference","title":"SummationByParts.Cubature.solvecubatureweights!","text":"Cubature.solvecubatureweights!{SymCub{T}}\n\nAttempts to solve for the weights of a cubature that is exact for polynomials of degree r <= q.  The weights (and nodes) of the cubature are defined by cub, which is a parametric abstract type (see symcubatures.jl).\n\nInputs\n\nq: maximum (desired) degree for which the cubature is exact\ntol: tolerance with which to solve the accuracy conditions\nhist: if true, print the residual-norm convergence history\n\nIn/Outs\n\ncub: on entry, defines the initial guess for the cubature nodes and weights. on exit, defines the nodes and weights that satisfy the desired accuracy.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.Cubature.tetcubature","page":"Reference","title":"SummationByParts.Cubature.tetcubature","text":"Cubature.tetcubature{T}\n\nThis high-level function computes and returns a symmetric cubature of requested accuracy on the right tetrahedron.\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\ninternal: if true, all nodes are strictly internal (default false)\nfacequad: if true, the cubatures' face nodes coincide with a quadrature\ntol: tolerance with which to solve the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right tetrahedron\nvtx: vertices for the right tetrahedron\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.Cubature.tricubature","page":"Reference","title":"SummationByParts.Cubature.tricubature","text":"Cubature.tricubature{T}\n\nDeprecated; this function will be removed in the future\n\nInputs\n\nq: maximum degree of polynomial for which the cubature is exact\nT: the data type used to represent the cubature\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# derivecubature.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.deriveTriCubatureOmega\nSummationByParts.deriveTriCubatureGamma\nSummationByParts.deriveTriCubatureDiagE\nSummationByParts.deriveTetCubatureOmega\nSummationByParts.deriveTetCubatureGamma\nSummationByParts.deriveTetCubatureDiagE","category":"page"},{"location":"reference/#SummationByParts.deriveTriCubatureOmega","page":"Reference","title":"SummationByParts.deriveTriCubatureOmega","text":"SummationByParts.deriveTriCubatureOmega\n\nThis function derives quadrature rules for SBP-Omega operators on the triangle.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumS21 : number of S21 orbits (vertex to opposite face)\nnumS111 : number of S111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.deriveTriCubatureGamma","page":"Reference","title":"SummationByParts.deriveTriCubatureGamma","text":"SummationByParts.deriveTriCubatureGamma\n\nThis function derives quadrature rules for SBP-Gamma operators on the triangle.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumS21 : number of S21 orbits (vertex to opposite face)\nnumS111 : number of S111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.deriveTriCubatureDiagE","page":"Reference","title":"SummationByParts.deriveTriCubatureDiagE","text":"SummationByParts.deriveTriCubatureDiagE\n\nThis function derives quadrature rules for SBP-Omega operators on the triangle.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumS21 : number of S21 orbits (vertex to opposite face)\nnumS111 : number of S111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\nxedge: parameters for the edge symmetry groups\nxedge_sym_group: list of the symmetry group ordering provided in xedge\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.deriveTetCubatureOmega","page":"Reference","title":"SummationByParts.deriveTetCubatureOmega","text":"SummationByParts.deriveTetCubatureOmega\n\nThis function derives quadrature rules for SBP-Omega operators on the tetrahedron.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nfacecentroid : if true, face centroids are present in the set of nodes\nnumedge : number of unique edge parameters\nnumfaceS21 : number of S21 face orbits (same tri orbit on face)\nnumfaceS111 : number of S111 face orbits (same tri orbit on face)\nnumS31 : number of S31 orbits (vertex to opposite face)\nnumS22 : number of S22 orbits\nnumS211: number of S211 orbits\nnumS1111: number of S1111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.deriveTetCubatureGamma","page":"Reference","title":"SummationByParts.deriveTetCubatureGamma","text":"SummationByParts.deriveTetCubatureGamma\n\nThis function derives quadrature rules for SBP-Gamma operators on the tetrahedron.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nfacecentroid : if true, face centroids are present in the set of nodes\nnumedge : number of unique edge parameters\nnumfaceS21 : number of S21 face orbits (same tri orbit on face)\nnumfaceS111 : number of S111 face orbits (same tri orbit on face)\nnumS31 : number of S31 orbits (vertex to opposite face)\nnumS22 : number of S22 orbits\nnumS211: number of S211 orbits\nnumS1111: number of S1111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.deriveTetCubatureDiagE","page":"Reference","title":"SummationByParts.deriveTetCubatureDiagE","text":"SummationByParts.deriveTetCubatureDiagE\n\nThis function derives quadrature rules for SBP diagonal-E operators on the tetrahedron.\n\nInputs\n\nq: the degree of the operator\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nfacecentroid : if true, face centroids are present in the set of nodes\nnumedge : number of unique edge parameters\nnumfaceS21 : number of S21 face orbits (same tri orbit on face)\nnumfaceS111 : number of S111 face orbits (same tri orbit on face)\nnumS31 : number of S31 orbits (vertex to opposite face)\nnumS22 : number of S22 orbits\nnumS211: number of S211 orbits\nnumS1111: number of S1111 orbits\ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nverbose: print out iteration results\nxinit: initial guess of the prameter and/or the parameter and weights\nxinit_sym_group: list of the symmetry group ordering provided in xinit\nxedge: parameters for the edge symmetry groups\nxedge_sym_group: list of the symmetry group ordering provided in xedge\n\nOutputs\n\ncub: a symmetric cubature for the right triangle\nvtx: vertices for the right triangle\n\n\n\n\n\n","category":"function"},{"location":"reference/#Differentiation","page":"Reference","title":"Differentiation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions related to strong and weak differentiation using the SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# differentiate\nThis file gathers together functions related to strong differentiation using\nthe SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.differentiate!\nSummationByParts.differentiateElement!","category":"page"},{"location":"reference/#SummationByParts.differentiate!","page":"Reference","title":"SummationByParts.differentiate!","text":"SummationByParts.differentiate!\n\nApplies the SBP differentiation matrix operator, D, to data in flux and stores the result in res.  Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-2 array, with the\n\nfirst dimension for the local-node index, and the second dimension for the element index.\n\nFor vector fields, flux is a rank-3 array, with the first dimension for\n\nthe index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.\n\nNaturally, the number of entries in the dimension of flux (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Dx, etc)\nflux: the array that the operator is applied to\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of applying inv(H)*Q[:,:,di] to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.differentiateElement!","page":"Reference","title":"SummationByParts.differentiateElement!","text":"SummationByParts.differentiateElement!\n\nThis is the single-element variant of differentiate!  Applies the SBP differentiation matrix operator, D, to data in flux and stores the result in res.  Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-1 array, with first\n\nand only dimension for the local-node index.\n\nFor vector fields, flux is a rank-2 array, with the first dimension for\n\nthe index of the vector field, and the second dimension for the local-node index.\n\nNaturally, the number of entries in the dimension of flux (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Dx, etc)\nflux: the array that the operator is applied to\n±: PlusFunctor to add to res, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\nres: where the result of applying inv(H)*Q[:,:,di] to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# differentiate_rev\n# This file contains the reverse-mode version of the methods in differentiate.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.differentiate_rev!\nSummationByParts.differentiateElement_rev!","category":"page"},{"location":"reference/#SummationByParts.differentiate_rev!","page":"Reference","title":"SummationByParts.differentiate_rev!","text":"SummationByParts.differentiate_rev!\n\nThis is the reverse differentiated version of differentiate!.  See differentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Dx, etc)\nres_bar: vector applied to the left of the D operator\n±: PlusFunctor to add to res_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: the result of the vector matrix product between D and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.differentiateElement_rev!","page":"Reference","title":"SummationByParts.differentiateElement_rev!","text":"SummationByParts.differentiateElement_rev!\n\nThis is the reverse differentiated version of differentiateElement!.  See differentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Dx, etc)\nres_bar: vector applied to the left of the D operator\n±: PlusFunctor to add to res_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: the result of the vector matrix product between D and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# directionaldifferentiate.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.directionalDifferentiateElement!","category":"page"},{"location":"reference/#SummationByParts.directionalDifferentiateElement!","page":"Reference","title":"SummationByParts.directionalDifferentiateElement!","text":"SummationByParts.directionalDifferentiateElement!\n\nPerforms a directional derivative (in reference space) at a given node.  The input field u is for a single element, not a collection of elements.\n\nWARNING: In the case of a vector field u, the directional derivative is   added to the output Ddir; the user must zero this before.\n\nInputs\n\nsbp: an SBP operator type\ndir: a direction vector for the directional derivative\nu: the field that is being differentiated (either a scalar or vector)\ni: index of the node at which the derivative is desired\n\nReturns or In/Outs\n\nDdir: derivative of u in direction dir\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# weakdifferentiate.jl\n# This file gathers together functions related to \"weak\" differentiation using\n# the SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.weakdifferentiate!\nSummationByParts.weakDifferentiateElement!","category":"page"},{"location":"reference/#SummationByParts.weakdifferentiate!","page":"Reference","title":"SummationByParts.weakdifferentiate!","text":"SummationByParts.weakdifferentiate!\n\nApplies the SBP stiffness matrix (or its transpose) to data in flux and adds to or subtracts from res.  Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-2 array, with the\n\nfirst dimension for the local-node index, and the second dimension for the element index.\n\nFor vector fields, flux is a rank-3 array, with the first dimension for\n\nthe index of the vector field, the second dimension for the local-node index, and the third dimension for the element index.\n\nNaturally, the number of entries in the dimension of flux (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Qx, etc)\nflux: the array that the operator is applied to\n± : PlusFunctor to add to res, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\nres: where the result of applying Q[:,:,di] to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.weakDifferentiateElement!","page":"Reference","title":"SummationByParts.weakDifferentiateElement!","text":"SummationByParts.weakDifferentiateElement!\n\nThis is the single-element variant of weakdifferentiate!.  Applies the SBP stiffness matrix (or its transpose) to data in flux and adds to or subtracts from res.  Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-1 array, with the only\n\ndimension for the local-node index.\n\nFor vector fields, flux is a rank-2 array, with the first dimension for\n\nthe index of the vector field, and the second dimension for the local-node index.\n\nNaturally, the number of entries in the dimension of flux (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Qx, etc)\nflux: the array that the operator is applied to\n± : PlusFunctor to add to res, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\nres: where the result of applying Q[:,:,di] to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# weakdifferentiate_rev.jl\n# This file contains the reverse-mode version of the methods in\n# weakdifferentiate.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.weakdifferentiate_rev!\nSummationByParts.weakDifferentiateElement_rev!","category":"page"},{"location":"reference/#SummationByParts.weakdifferentiate_rev!","page":"Reference","title":"SummationByParts.weakdifferentiate_rev!","text":"SummationByParts.weakdifferentiate_rev!\n\nThis is the reverse differentiated version of weakdifferentiate!.  See weakdifferentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Qx, etc)\nres_bar: vector applied to the left of the Q operator\n± : PlusFunctor to add to res_bar, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\nflux_bar: the result of the vector matrix product between Q and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.weakDifferentiateElement_rev!","page":"Reference","title":"SummationByParts.weakDifferentiateElement_rev!","text":"SummationByParts.weakDifferentiateElement_rev!\n\nThis is the reverse differentiated version of weakDifferentiateElement!.  See weakdifferentiate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Qx, etc)\nres_bar: vector applied to the left of the Q operator\n± : PlusFunctor to add to res_bar, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\nflux_bar: the result of the vector matrix product between Q and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# weakdifferentiate_jac.jl\n# This file gathers together functions related to forming Jacobians of \"weak\"\n# differentiation using the SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.weakDifferentiateElement_jac!","category":"page"},{"location":"reference/#SummationByParts.weakDifferentiateElement_jac!","page":"Reference","title":"SummationByParts.weakDifferentiateElement_jac!","text":"SummationByParts.weakDifferentiateElement_jac!\n\nThis function applies the SBP stiffness matrix (or its transpose) to a diagonal, or block diagonal, matrix of flux jacobians dfluxdu.  The resulting matrix is added to or subtracted from dresdu.  Different methods are available depending on the rank of dfluxdu:\n\nFor scalar fields, it is assumed that dfluxdu is a rank-1 array, with the\n\nonly dimension for the local-node index.  dresdu is a rank-2 array, with size sbp.numnodes x sbp.numnodes.\n\nFor vector fields, dfluxdu is a rank-3 array, with the first and second\n\ndimensions for indices of the vector field (at a particular node) and the second dimension for the local-node index.  dresdu is a rank-4 array; the first 2 dimensions are of size nvar = size(dfluxdu,1), while the third and fourth dimensions are of size sbp.numnodes.\n\nNaturally, the number of entries in the dimension of dfluxdu (and dresdu) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\ndi: direction index of the operator that is desired (di=1 for Qx, etc)\ndfluxdu: array of the derivative of the flux w.r.t. the state\n± : PlusFunctor to add to res, MinusFunctor to subract\ntrans (optional): if true, the transpose operation is applied\n\nIn/Outs\n\ndresdu: stores Q[:,:,di]diag(dfluxdu) or Q[:,:,di]'diag(dfluxdu)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# edgestabilize.jl\n# Applies edge stabilization to a given field, differentiating in the\n# direction specified by `dirvec`, and scaling by the `tau` field.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.edgestabilize!","category":"page"},{"location":"reference/#SummationByParts.edgestabilize!","page":"Reference","title":"SummationByParts.edgestabilize!","text":"SummationByParts.edgestabilize!\n\nApplies edge stabilization to a given field, differentiating in the direction specified by dirvec, and scaling by the tau field.\n\nInputs\n\nsbpface: an SBP face operator type\nifaces: list of element interfaces stored as an array of Interfaces\ndirvec: direction to differentiate in [xi coord, face node, L/R, face] format\ntau: scaling term in [face node, face] format\nu: field being stablized in [vol node, element] format\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result is stored in [vol node, element] format\n\n\n\n\n\n","category":"function"},{"location":"reference/#Integration","page":"Reference","title":"Integration","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions related to volumne and face integration over a test function using SBP operators.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# faceintegrate.jl\n# This file gathers together methods related to integration over faces, both\n# against test functions and for integral functionals.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.integratefunctional!\nSummationByParts.integrateBoundaryFunctional!\nSummationByParts.boundaryintegrate!\nSummationByParts.boundaryFaceIntegrate!\nSummationByParts.interiorfaceintegrate!\nSummationByParts.interiorFaceIntegrate!","category":"page"},{"location":"reference/#SummationByParts.integratefunctional!","page":"Reference","title":"SummationByParts.integratefunctional!","text":"SummationByParts.integratefunctional!\n\nIntegrates a given scalar (or vector) field over the boundary faces.\n\nFor scalar fields, the dimensions of uface correspond to [face-node index, boundary index] and the scalar functional is a return value\nFor vector fields, the dimensions of uface correspond to [field index, face-node index, boundary index] and the dimensions of fun correspond to [field index].\n\nInputs\n\nsbpface: an SBP face operator type\nbndryfaces: list of boundary faces stored as an array of Boundarys\nflux:  array of field data that is being integrated\n±: PlusFunctor to add to fun, MinusFunctor to subract\n\nIn/Outs\n\nfun: functional value (or vector) being contributed to by the integration\n\nReturns\n\nfun: in the case of the scalar version, the functional value is returned\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.integrateBoundaryFunctional!","page":"Reference","title":"SummationByParts.integrateBoundaryFunctional!","text":"SummationByParts.integrateBoundaryFunctional!\n\nThis is the single-face variant of integratefunctional!.  Integrates a given scalar (or vector) field over the boundary faces.\n\nFor scalar fields, the dimensions of uface correspond to [face-node index] and the scalar functional is a return value\nFor vector fields, the dimensions of uface correspond to [field index, face-node index] and the dimensions of fun correspond to [field index].\n\nInputs\n\nsbpface: an SBP face operator type\nface: the face of the element to integrate\nflux:  array of field data that is being integrated\n±: PlusFunctor to add to fun, MinusFunctor to subract\n\nIn/Outs\n\nfun: functional value (or vector) being contributed to by the integration\n\nReturns\n\nfun: in the case of the scalar version, the functional value is returned\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundaryintegrate!","page":"Reference","title":"SummationByParts.boundaryintegrate!","text":"SummationByParts.boundaryintegrate!\n\nScales flux values at boundary cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-2 array, with the\n\nfirst dimension for the face-node index, and the second dimension for the boundary index.\n\nFor vector fields, flux is a rank-3 array, with the first dimension for\n\nthe index of the vector field, the second dimension for the face-node index, and the third dimension for the boundary index.\n\nThe dimensions of res are still based on elements; the last dimension is for the element index and the second-last dimension is for the element-local node index.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nbndryfaces: list of boundary faces stored as an array of Boundarys\nflux: array of flux data that is being integrated\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of the integration is stored\n\nWARNING: the order of the boundaries in bndryfaces and flux must be   consistent.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundaryFaceIntegrate!","page":"Reference","title":"SummationByParts.boundaryFaceIntegrate!","text":"SummationByParts.boundaryFaceIntegrate!\n\nThis is the single-face variant of boundaryintegrate!. Scales flux values at boundary cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-1 array, with the\n\nfirst and only dimension for the face-node index.\n\nFor vector fields, flux is a rank-2 array, with the first dimension for\n\nthe index of the vector field, and the second dimension for the face-node index.\n\nThe dimensions of res are still based on elements; the last dimension (in the scalar case, the only dimension) is for the element-local node index.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nface: the face of the element to integrate and project back to the element\nflux: array of flux data that is being integrated\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of the integration is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.interiorfaceintegrate!","page":"Reference","title":"SummationByParts.interiorfaceintegrate!","text":"SummationByParts.interiorfaceintegrate!\n\nScales flux values at element-interface cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes. Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-2 array, with the\n\nfirst dimension for the face-node index, and the second dimension for the interface index.\n\nFor vector fields, flux is a rank-3 array, with the first dimension for\n\nthe index of the vector field, the second dimension for the face-node index, and the third dimension for the interface index.\n\nThe dimensions of res are still based on elements; the last dimension is for the element index and the second-last dimension is for the element-local node index.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nifaces: list of element interfaces stored as an array of Interfaces\nflux: array of flux data that is being integrated\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of the integration is stored\n\nWARNING: the order of the interfaces in ifaces and flux must be   consistent.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.interiorFaceIntegrate!","page":"Reference","title":"SummationByParts.interiorFaceIntegrate!","text":"SummationByParts.interiorFaceIntegrate!\n\nThis is the single-face variant of interiorfaceintegrate!.  Scales flux values at element-interface cubature points by cubature weights, and then performs transposed interpolation/extrapolation back to volume nodes.  Different methods are available depending on the rank of flux:\n\nFor scalar fields, it is assumed that flux is a rank-1 array, with the\n\nfirst and only dimension for the face-node index\n\nFor vector fields, flux is a rank-2 array, with the first dimension for\n\nthe index of the vector field, and the second dimension for the face-node index\n\nThe dimensions of resL and resR are still based on elements; the last dimension (in the scalar case, the only dimension) is for the element-local node index.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nifaces: list of element interfaces stored as an array of Interfaces\nflux: array of flux data that is being integrated\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nresL: where the result of the integration is stored for the left element\nresR: where the result of the integration is stored for the right element\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# faceintegrate_rev.jl\n# This file contains the reverse-mode version of the methods in faceintegrate.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.integratefunctional_rev!\nSummationByParts.integrateBoundaryFunctional_rev!\nSummationByParts.boundaryintegrate_rev!\nSummationByParts.boundaryFaceIntegrate_rev!\nSummationByParts.interiorfaceintegrate_rev!\nSummationByParts.interiorFaceIntegrate_rev!","category":"page"},{"location":"reference/#SummationByParts.integratefunctional_rev!","page":"Reference","title":"SummationByParts.integratefunctional_rev!","text":"SummationByParts.integratefunctional_rev!\n\nThis is the reverse differentiated version of integratefunctional!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP face operator type\nbndryfaces: list of boundary faces stored as an array of Boundarys\nfun_bar: incoming quantity that multiplies the functional from the left\n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector-Jacobian product.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.integrateBoundaryFunctional_rev!","page":"Reference","title":"SummationByParts.integrateBoundaryFunctional_rev!","text":"SummationByParts.integrateBoundaryFunctional_rev!\n\nThis is the reverse differentiated version of integrateBoundaryFunctional!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP face operator type\nface: the face of the element to integrate\nfun_bar: incoming quantity that multiplies the functional from the left\n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector-Jacobian product.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundaryintegrate_rev!","page":"Reference","title":"SummationByParts.boundaryintegrate_rev!","text":"SummationByParts.boundaryintegrate_rev!\n\nThis is the reverse differentiated version of boundaryintegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nbndryfaces: list of boundary faces stored as an array of Boundarys\nres_bar: vector applied to the left of the (R^T*B) operator\n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector matrix product between (R^T*B) and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.boundaryFaceIntegrate_rev!","page":"Reference","title":"SummationByParts.boundaryFaceIntegrate_rev!","text":"SummationByParts.boundaryFaceIntegrate_rev!\n\nThis is the reverse differentiated version of boundaryFaceIntegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nface: the face of the element to integrate and project back to the element\nres_bar: vector applied to the left of the (R^T*B) operator\n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector matrix product between (R^T*B) and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.interiorfaceintegrate_rev!","page":"Reference","title":"SummationByParts.interiorfaceintegrate_rev!","text":"SummationByParts.interiorfaceintegrate_rev!\n\nThis is the reverse differentiated version of interiorfaceintegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nifaces: list of element interfaces stored as an array of Interfaces\nres_bar: vector applied to the left of the (R^T*B) operator\n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector matrix product between (R^T*B) and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.interiorFaceIntegrate_rev!","page":"Reference","title":"SummationByParts.interiorFaceIntegrate_rev!","text":"SummationByParts.interiorFaceIntegrate_rev!\n\nThis is the reverse differentiated version of interiorFaceIntegrate!.  See faceintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's flux variable.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nifaces: list of element interfaces stored as an array of Interfaces\nresL_bar: vector (left element) applied to the left of the (R^T*B) operator \nresR_bar: vector (right element) applied to the left of the (R^T*B) operator \n±: PlusFunctor to add to flux_bar, MinusFunctor to subract\n\nIn/Outs\n\nflux_bar: result of the vector-matrix product\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# faceintegrate_jac.jl\n# This file gathers together methods related to computing the Jacobian of\n# face-based integral terms; it combines operations from both faceinterpolate\n# and faceintegrate.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.boundaryFaceIntegrate_jac!\nSummationByParts.interiorFaceIntegrate_jac!","category":"page"},{"location":"reference/#SummationByParts.boundaryFaceIntegrate_jac!","page":"Reference","title":"SummationByParts.boundaryFaceIntegrate_jac!","text":"SummationByParts.boundaryFaceIntegrate_jac!\n\nGiven the face-node flux Jacobians, this method computes the Jacobian of the chain boundaryFaceInterpolate! –> face-flux evaluation –> boundaryFaceIntegrate!  and adds the contributions to the relevant element's Jacobian matrix.  Different methods are available depending on the rank of dfluxdu:\n\nFor scalar fields, it is assumed that dfluxdu is a rank-1 array, with the\n\nonly dimension for the face local-node index.  dresdu is the Jacobian of the element residual with respect to the state.\n\nFor vector fields, dfluxdu is a rank-3 array, with the first and second\n\ndimensions for indices of the vector field (at a particular face node) and the second dimension for the face local-node index.  dresdu is a rank-4 array that is the Jacobian of the element residual with respect to the state; the first 2 dimensions are of size nvar = size(dfluxdu,1), while the third and fourth dimensions are of size sbp.numnodes.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nface: the relevant face (index) of the element\ndfluxdu: array of the derivative of the flux w.r.t. the state trace\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\ndresdu: Jacobian of element residual w.r.t. the state\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.interiorFaceIntegrate_jac!","page":"Reference","title":"SummationByParts.interiorFaceIntegrate_jac!","text":"SummationByParts.interiorFaceIntegrate_jac!\n\nGiven the face-node flux Jacobians, this method computes the Jacobian of the chain interiorFaceInterpolate! –> face-flux evaluation –> interiorFaceIntegrate!  and adds the contributions to the adjacent elements' Jacobians matrices.  Different methods are available depending on the rank of dfluxduL and dfluxduR:\n\nFor scalar fields, it is assumed that dfluxduL and dfluxduR are rank-1\n\narrays, with the only dimension for the face local-node index.  dresLduL is the Jacobian of the left-element residual with respect to the left-element solution, and similarly for dresLduR, dresRduL, dresRduR.\n\nFor vector fields, dfluxduL and dfluxduR are rank-3 arrays, with the\n\nfirst and second dimensions for indices of the vector field (at a particular face node) and the second dimension for the face local-node index.  dresLduL is a rank-4 array that is the Jacobian of the left-element residual with respect to the left-element solution; the first 2 dimensions are of size nvar = size(dfluxduL,1), while the third and fourth dimensions are of size sbp.numnodes.  Similarly for dresLduR, dresRduL, dresRduR.\n\nInputs\n\nsbpface: an SBP AbstractFace type\nifaces: list of element interfaces stored as an array of Interfaces\ndfluxduL: array of the derivative of the flux w.r.t. the left trace\ndfluxduR: array of the derivative of the flux w.r.t. the right trace\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\ndresLduL: Jacobian of left residual w.r.t. left state\ndresLduR: Jacobian of left residual w.r.t. right state\ndresRduL: Jacobian of right residual w.r.t. left state\ndresRduR: Jacobian of right residual w.r.t. right state\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# volumeintegrate.jl\n# This file gathers together functions related to volumne integration over a\n# test function using SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.volumeintegrate!\nSummationByParts.volumeIntegrateElement!","category":"page"},{"location":"reference/#SummationByParts.volumeintegrate!","page":"Reference","title":"SummationByParts.volumeintegrate!","text":"SummationByParts.volumeintegrate!\n\nApplies the SBP mass matrix operator, H, to data in u and stores the result in res.  Different methods are available depending on the rank of u:\n\nFor scalar fields, it is assumed that u is a rank-2 array, with the first\n\ndimension for the local-node index, and the second dimension for the element index.\n\nFor vector fields, u is a rank-3 array, with the first dimension for the\n\nindex of the vector field, the second dimension for the local-node index, and the third dimension for the element index.\n\nNaturally, the number of entries in the dimension of u (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\nu: the array that the operator is applied to\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of applying H to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.volumeIntegrateElement!","page":"Reference","title":"SummationByParts.volumeIntegrateElement!","text":"SummationByParts.volumeIntegrateElement!\n\nThis is the single-element variant of volumeIntegrate!.  Applies the SBP mass matrix operator, H, to data in u and stores the result in res.  Different methods are available depending on the rank of u:\n\nFor scalar fields, it is assumed that u is a rank-1 array, with the first\n\nand only dimension for the local-node index.\n\nFor vector fields, u is a rank-2 array, with the first dimension for the\n\nindex of the vector field, and the second dimension for the local-node index.\n\nNaturally, the number of entries in the dimension of u (and res) corresponding to the nodes must be equal to the number of nodes in the SBP operator sbp.\n\nInputs\n\nsbp: an SBP operator type\nu: the array that the operator is applied to\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nres: where the result of applying H to u is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# volumeintegrate_rev.jl\n# This file contains the reverse-mode version of the methods in\n# volumeintegrate.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.volumeintegrate_rev!\nSummationByParts.volumeIntegrateElement_rev!","category":"page"},{"location":"reference/#SummationByParts.volumeintegrate_rev!","page":"Reference","title":"SummationByParts.volumeintegrate_rev!","text":"SummationByParts.volumeintegrate_rev!\n\nThis is the reverse differentiated version of volumeintegrate!.  See volumeintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's u variable.\n\nInputs\n\nsbp: an SBP operator type\nres_bar: vector applied to the left of the H operator\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nu_bar: the result of the vector matrix product between H and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.volumeIntegrateElement_rev!","page":"Reference","title":"SummationByParts.volumeIntegrateElement_rev!","text":"SummationByParts.volumeIntegrateElement_rev!\n\nThis is the reverse differentiated version of volumeIntegrateElement!.  See volumeintegrate.jl for further details of the primal method.  This function is differentiated with respect to the primal version's u variable.\n\nInputs\n\nsbp: an SBP operator type\nres_bar: vector applied to the left of the H operator\n±: PlusFunctor to add to res, MinusFunctor to subract\n\nIn/Outs\n\nu_bar: the result of the vector matrix product between H and res_bar\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mapping","page":"Reference","title":"Mapping","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions related to the calculation of the coordinate mapping Jacobian on elements and faces.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# mappingjacobian.jl\n# This file gathers together functions related to the calculation of the\n# coordinate mapping Jacobian on elements and faces","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.calcMappingJacobian!\nSummationByParts.calcMappingJacobianElement!\nSummationByParts.mappingjacobian!","category":"page"},{"location":"reference/#SummationByParts.calcMappingJacobian!","page":"Reference","title":"SummationByParts.calcMappingJacobian!","text":"SummationByParts.calcMappingJacobian!\n\nUses a given set of Lagrangian element nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the Jacobian of the mapping.  The approach varies depending on the dimension of the problem:\n\nFor 2-dimensional problems the exact Jacobian of the mapping is used;\nFor 3-dimensional problems an optimization problem is solved\n\nInputs\n\nsbp: an SBP operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagrangian node, element]\nEone: Exone, Eyone (Ez*one); [sbp node, coord, element] see notes below\n\nIn/Outs\n\nxsbp: location of the SBP nodes in physical space; [coord, sbp node, element]\ndξdx: scaled Jacobian of mapping; [ref coord, phys coord, sbp node, element]\njac: the determinant of the Jacobian; [sbp node, element]\n\nNotes\n\nThe array Eone is the product of the boundary operators, in physical space, with the vector of ones (see Crean et al., Entropy-Conservative, Multidimensional Summation-By-Parts Discretization of the Euler Equations, as well as the test in test/test_mappingjacobian.jl).  These products are used to define the metric invariants.  They are not needed by the 2-dimensional code, and so this array can be passed empty in that case.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcMappingJacobianElement!","page":"Reference","title":"SummationByParts.calcMappingJacobianElement!","text":"SummationByParts.calcMappingJacobianElement!\n\nSingle element variant of calcMappingJacobian!.  Uses a given set of Lagrangian element nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the Jacobian of the mapping.  The approach varies depending on the dimension of the problem:\n\nFor 2-dimensional problems the exact Jacobian of the mapping is used;\nFor 3-dimensional problems an optimization problem is solved\n\nInputs\n\nsbp: an SBP operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagrangian node]\nEone: Exone, Eyone (Ez*one); [sbp node, coord] see notes below\n\nIn/Outs\n\nxsbp: location of the SBP nodes in physical space; [coord, sbp node]\ndξdx: the scaled Jacobian of the mapping; [ref coord, phys coord, sbp node]\njac: the determinant of the Jacobian; [sbp node]\n\nNotes\n\nThe array Eone is the product of the boundary operators, in physical space, with the vector of ones (see Crean et al., Entropy-Conservative, Multidimensional Summation-By-Parts Discretization of the Euler Equations, as well as the test in test/test_mappingjacobian.jl).  These products are used to define the metric invariants.  They are not needed by the 2-dimensional code, and so this array can be passed empty in that case.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.mappingjacobian!","page":"Reference","title":"SummationByParts.mappingjacobian!","text":"SummationByParts.mappingjacobian!\n\nEvaluates the Jacobian of the mapping from face-reference coordinates to physical coordinates, as well as the determinant of the Jacobian.\n\nInputs\n\nsbpface: an SBP face operator type\nifaces: list of element interfaces stored as an array of Interfaces\nx: the physical coordinates in [coord, node, elem] format\n\nIn/Outs\n\ndξdx: the Jacobian in [ξ coord, x coord, face node, L/R, face] format\njac: the determinant in [face node, L/R, face] format\n\n\n\n\n\nSummationByParts.mappingjacobian!\n\nDeprecated:\n\nEvaluates the (scaled) Jacobian of the mapping from reference coordinates to physical coordinates, as well as the determinant of the Jacobian.  The values returned in dξdx are scaled by the determinant, so they have the same units as the boundary measure (i.e. length in 2D, or length^2 in 3D).  This scaling is adopted, because conservation laws written in conservative form in the reference frame use the scaled Jacobian.\n\nInputs\n\nsbp: an SBP operator type\nx: the physical coordinates; 1st dim = coord, 2nd dim = node, 3rd dim = elem\n\nIn/Outs\n\ndξdx: the scaled Jacobian of the mapping; 1st dim = ref coord, 2nd dim = phys coord, 3rd dim = node, 3rd dim = elem\njac: the determinant of the Jacobian; 1st dim = node, 2nd dim = elem\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# mappingjacobian_rev.jl\n# This file gathers together functions related to the reverse-mode differentiation of \n# mapping Jacobian","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.calcMappingJacobian_rev!\nSummationByParts.mappingjacobian_rev!","category":"page"},{"location":"reference/#SummationByParts.calcMappingJacobian_rev!","page":"Reference","title":"SummationByParts.calcMappingJacobian_rev!","text":"SummationByParts.calcMappingJacobian_rev!\n\nForms the reverse-mode of algorithmic differentiation product for the method calcMappingJacobian!.  Specifically, it computes xlag_bar = xsbp_bar^T * ∂xsbp/∂xlag + dξdx_bar^T * ∂dξdx/∂xlag + jac_bar^T * ∂jac/∂xlag and Eone_bar = dξdx_bar^T * ∂dξdx/∂xlag where the various quantities are defined below (the _bar denotes the reverse mode).  Note that the input and output order of the arguments follows that used in calcMappingJacobian!.\n\nInputs\n\nsbp: an SBP operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxsbp_bar: gradient w.r.t. SBP nodes; [coord, sbp node]\ndξdx: scaled Jacobian of mapping (as output from calcMappingJacobian!)\ndξdx_bar: gradient w.r.t. Jacobian; [ref coord, phys coord, sbp node, element]\njac: the determinant of the Jacobian (as output from calcMappingJacobian!)\njac_bar: gradient w.r.t. determinant of the Jacobian; [sbp node, element]\n\nIn/Outs\n\nxlag_bar: gradient w.r.t. Lagrangian nodes; [coord, Lagrangian node, element]\nEone_bar: gradient w.r.t. Exone, Eyone (Ez*one); [sbp node, coord, element]\n\nNotes\n\nSee calcMappingJacobian! for an explanation of Eone; it is only needed in the 3D case, but Eone_bar needs to be supplied in both 2D and 3D.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.mappingjacobian_rev!","page":"Reference","title":"SummationByParts.mappingjacobian_rev!","text":"SummationByParts.mappingjacobian_rev!\n\nDeprecated:\n\nForms the reverse-mode of algorithmic differentiation product for the method mappingjacobian!.  Specifically, it computes x_bar = dξdx_bar^T * ∂dξdx/∂x + jac_bar^T * ∂jac/∂x where the various quantities are defined below (the _bar denotes the reverse mode).  Note that the input and output order of the arguments follows that used in mappingjacobian!.\n\nInputs\n\nsbp: an SBP operator type\nx: the physical coordinates; 1st dim = coord, 2nd dim = node, 3rd dim = elem\ndξdx_bar: gradient w.r.t. Jacobian; [ref coord, phys coord, sbp node, element]\njac_bar: gradient w.r.t. determinant of the Jacobian; [sbp node, element]\n\nIn/Outs\n\nx_bar: gradient w.r.t. SBP nodes; [coord, Lagrangian node, element]\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# facenormal.jl\n# This file gathers together functions related to the calculation of scaled face\n# normals for general (curvilinear) faces","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.calcFaceNormals!\nSummationByParts.facenormal!","category":"page"},{"location":"reference/#SummationByParts.calcFaceNormals!","page":"Reference","title":"SummationByParts.calcFaceNormals!","text":"SummationByParts.calcFaceNormals!\n\nUses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lag node]\nxlag: Lagrangian nodes in physical space; [coord, Lag node, face]\n\nIn/Outs\n\nxsbp: SBP-face nodes in physical space; [coord, sbp node, face]\nnrm: scaled face-normal at the sbpface nodes; [component, sbp node, face]\n\n\n\n\n\nSummationByParts.calcFaceNormals!\n\nUses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lag node]\nxlag: Lagrangian nodes in physical space; [coord, Lag node, face]\n\nIn/Outs\n\nxsbp: SBP-face nodes in physical space; [coord, sbp node, face]\nnrm: scaled face-normal at the sbpface nodes; [component, sbp node, face]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.facenormal!","page":"Reference","title":"SummationByParts.facenormal!","text":"SummationByParts.facenormal!\n\nThis is the single-face variant of calcFaceNormals!.  Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagrangian node]\n\nIn/Outs\n\nxsbp: location of the SBP-face nodes in physical space; [coord, sbp node]\nnrm: scaled face-normal at the sbpface nodes\n\n\n\n\n\nSummationByParts.facenormal!\n\nThis is the single-face variant of calcFaceNormals!.  Uses a given set of Lagrangian face nodes to determine an analytical (polynomial) mapping, and then uses this mapping to determine the scaled face-normal vector.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagrangian node]\n\nIn/Outs\n\nxsbp: location of the SBP-face nodes in physical space; [coord, sbp node]\nnrm: scaled face-normal at the sbpface nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"# facenormal_rev.jl\n# This file contains the reverse-mode version of the methods in\n# facenormal.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.calcFaceNormals_rev!\nSummationByParts.facenormal_rev!","category":"page"},{"location":"reference/#SummationByParts.calcFaceNormals_rev!","page":"Reference","title":"SummationByParts.calcFaceNormals_rev!","text":"SummationByParts.calcFaceNormals_rev!\n\nThis is the reverse differentiated version of calcFaceNormals!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version's xsbp and nrm variables.\n\nNote: xlag must be provided, but is only needed for the TetFace method.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lag node]\nxlag: Lagrangian nodes in physical space; [coord, Lag node, face]\nxsbp_bar: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node, face]\nnrm_bar: multiplies d(nrm)/d(xlag) from the left; [component, sbp node, face]\n\nIn/Outs\n\nxlag_bar: result of vector Jacobian product; [coord, Lag node, face]\n\n\n\n\n\nSummationByParts.calcFaceNormals_rev!\n\nThis is the reverse differentiated version of calcFaceNormals!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version's xsbp and nrm variables.\n\nNote: xlag must be provided, but is only needed for the TetFace method.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lag node]\nxlag: Lagrangian nodes in physical space; [coord, Lag node, face]\nxsbp_bar: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node, face]\nnrm_bar: multiplies d(nrm)/d(xlag) from the left; [component, sbp node, face]\n\nIn/Outs\n\nxlag_bar: result of vector Jacobian product; [coord, Lag node, face]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.facenormal_rev!","page":"Reference","title":"SummationByParts.facenormal_rev!","text":"SummationByParts.facenormal_rev!\n\nThis is the reverse differentiated version of facenormal!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version's xsbp and nrm variables.\n\nNote: xlag must be provided, but is only needed for the TetFace method.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagragnian node]\nxsbp_bar: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node]\nnrm_bar: multiplies d(nrm)/d(xlag) from the left; [component, sbp node]\n\nIn/Outs\n\nxlag_bar: result of vector Jacobian product; [coord, Lagrangian node]\n\n\n\n\n\nSummationByParts.facenormal_rev!\n\nThis is the reverse differentiated version of facenormal!.  See facenormal.jl for further details of the primal method.  This function is differentiated with respect to the primal version's xsbp and nrm variables.\n\nNote: xlag must be provided, but is only needed for the TetFace method.\n\nInputs\n\nsbpface: an SBP face operator type\nmapdegree: the polynomial degree of the mapping\nxref: Lagrangian nodes in reference space; [coord, Lagrangian node]\nxlag: Lagrangian nodes in physical space; [coord, Lagragnian node]\nxsbp_bar: multiplies d(xsbp)/d(xlag) from left; [coord, sbp node]\nnrm_bar: multiplies d(nrm)/d(xlag) from the left; [component, sbp node]\n\nIn/Outs\n\nxlag_bar: result of vector Jacobian product; [coord, Lagrangian node]\n\n\n\n\n\n","category":"function"},{"location":"reference/#Optimizer-Module","page":"Reference","title":"Optimizer Module","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions for optimization. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# optimizer.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SummationByParts.Optimizer]","category":"page"},{"location":"reference/#SummationByParts.Optimizer.levenberg_marquardt-Union{Tuple{T}, Tuple{Function, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T","page":"Reference","title":"SummationByParts.Optimizer.levenberg_marquardt","text":"SummationByParts.levenberg_marquardt\n\nLevenberg-Marquardt Algorithm (LMA) \n\nInputs\n\nfun: function to be optimized\ncub: cubature data\nq: the degree of the quadrature rule\nmask: a vector of the index of the parameters to be determined\nnp: number of particles \nxinit: initial parameter guess\nxL: lower bound on the parameters \nxR: upper bound on the parameters \nnu: parameter controling exploration (spliting between Newton's and steepest decent methods)\nmaxiter: maximum number of iterations \ntol: tolerance to stop iteration \nverbose: boolean to print results of iteration periodically\n\nOutputs\n\nfmin: the optimized function value\nv: the minimizer (solution)\niter: number of itrations\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.Optimizer.pso-Union{Tuple{T}, Tuple{Function, Int64, SummationByParts.SymCubatures.SymCub{T}, Int64, AbstractVector{Int64}}} where T","page":"Reference","title":"SummationByParts.Optimizer.pso","text":"SummationByParts.pso\n\nParticle Swarm Optimization (PSO) Algorithm\n\nInputs\n\nfun: function to be optimized\nne: number of parameters to be found\ncub: cubature data\nq: the degree of the quadrature rule\nmask: a vector of the index of the parameters to be determined\nnp: number of particles \nxinit: initial parameter guess\nxL: lower bound on the parameters \nxR: upper bound on the parameters \ndelta1: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin <= 0.1\ndelta2: purturbation constant that determines how much the parameters are perturbed           in the case of stagnation with fmin > 0.1\nmaxiter: maximum number of iterations (default is 1000)\ntol: tolerance to stop iteration (default is 1e-14)\nsave_iter: boolean to save results of each iteration\nverbose: boolean to print results of iteration periodically\n\nOutputs\n\nfmin: the optimized function value\nxmin: the minimizer (solution)\nf_all: all function evaluations\n\n\n\n\n\n","category":"method"},{"location":"reference/#OrthoPoly-Module","page":"Reference","title":"OrthoPoly Module","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions for working with orthogonal polynomials.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# orthopoly.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SummationByParts.OrthoPoly]","category":"page"},{"location":"reference/#SummationByParts.OrthoPoly.diffjacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.diffjacobipoly","text":"OrthoPoly.diffjacobipoly{T}\n\nEvaluate the first derivative of a Jacobi Polynomial at some points.\n\nInputs\n\nx: points at which to evaluate polynomial derivative\nalpha,beta: define the type of Jacobi Polynomial (alpha + beta != 1)\nN: polynomial degree\n\nOutputs\n\ndP - derivative of polynomial evaluated at x\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.diffproriolpoly","text":"OrthoPoly.diffproriolpoly{T}\n\nEvaluate the derivatives of a Proriol orthogonal polynomial basis function on the right tetrahedron.\n\nNotes: the derivatives are computed using the complex-step method (since there  are many outputs and only 3 inputs); therefore, a different method should be  used for verification of this method.\n\nInputs\n\nx,y,z: locations at which to evaluate the derivative\ni,j,k: index triple that defines the basis function to differentiate; see Hesthaven and Warburton's Nodal DG book, for example, for a reference.\n\nOutputs\n\ndPdx,dPdy,dPdz: derivatives of basis function at (x,y,z)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.diffproriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.diffproriolpoly","text":"OrthoPoly.diffproriolpoly\n\nEvaluate the derivatives of a Proriol orthogonal polynomial basis function on the right triangle.\n\nInputs\n\nx,y: locations at which to evaluate the derivative\ni,j: index pair that defines the basis function to differentiate; see Hesthaven and Warburton's Nodal DG book, for example, for a reference.\n\nOutputs\n\ndPdx,dPdy: derivative of basis function at (x,y)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.jacobipoly-Union{Tuple{T}, Tuple{Array{T}, AbstractFloat, AbstractFloat, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.jacobipoly","text":"OrthoPoly.jacobipoly{T}\n\nEvaluate a Jacobi polynomial at some points.  Based on JacobiP in Hesthaven and Warburton's nodal DG book.\n\nInputs\n\nx: points at which to evaluate polynomial\nalpha,beta: define the type of Jacobi Polynomial (alpha + beta != 1)\nN: polynomial degree\n\nOutputs\n\nP: the polynomial evaluated at x\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.lglnodes","page":"Reference","title":"SummationByParts.OrthoPoly.lglnodes","text":"OrthoPoly.lglnodes\n\nComputes the Legendre-Gauss-Lobatto (LGL) quadrature nodes and weights on the interval [-1,1].  The LGL nodes are the zeros of (1-x^2)*P'N(x), where PN(x) denotes the Nth Legendre polynomial.\n\nReference: C. Canuto, M. Y. Hussaini, A. Quarteroni, T. A. Tang, \"Spectral  Methods in Fluid Dynamics,\" Section 2.3. Springer-Verlag 1987\n\nInputs\n\nN: highest degree (number of nodes = N+1)\nT: number type\n\nOutputs\n\nx: the LGL nodes\nw: the LGL weights\n\nJulia version adapted from Matlab code written by Greg von Winckel - 04/17/2004 Contact: gregvw@chtm.unm.edu\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.OrthoPoly.lgnodes","page":"Reference","title":"SummationByParts.OrthoPoly.lgnodes","text":"OrthoPoly.lgnodes\n\nComputes the Legendre-Gauss (LG) quadrature nodes and weights on the interval [-1,1].  The LG nodes are the zeros of PN(x), where PN(x) denotes the Nth Legendre polynomial.\n\nInputs\n\nN: number of nodes\nT: number type\n\nOutputs\n\nx: the LG nodes\nw: the LG weights\n\nJulia version adapted from Matlab code written by Greg von Winckel - 02/25/2004 Contact: gregvw@chtm.unm.edu\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Array{T}, Int64, Int64, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.proriolpoly","text":"OrthoPoly.proriolpoly{T}: method for a right tetrahedron\n\nEvaluate Proriol orthogonal polynomial basis function on the right tetrahedron.\n\nInputs\n\nx,y,z: locations at which to evaluate the polynomial\ni,j,k: index triple that defines the basis function to evaluate; see Hesthaven and Warburton's Nodal DG book, for example, for a reference.\n\nOutputs\n\nP: basis function at (x,y,z)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.proriolpoly-Union{Tuple{T}, Tuple{Array{T}, Array{T}, Int64, Int64}} where T<:Number","page":"Reference","title":"SummationByParts.OrthoPoly.proriolpoly","text":"OrthoPoly.proriolpoly{T}: method for right triangle\n\nEvaluate Proriol orthogonal polynomial basis function on the right triangle.\n\nInputs\n\nx,y: locations at which to evaluate the polynomial\ni,j: index pair that defines the basis function to evaluate; see Hesthaven and Warburton's Nodal DG book, for example, for a reference.\n\nOutputs\n\nP: basis function at (x,y)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde","text":"OrthoPoly.vandermonde{T}\n\nEvaluate the Vandermonde matrix using the Proriol polynomials on the right tetrahedron.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y,z: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\n\nOutputs\n\nV: the Vandermonde matrix \nVdx,Vdy,Vdz: derivatives of the Vandermonde matrix at (x,y,z)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde","text":"OrthoPoly.vandermonde{T}\n\nEvaluate the Vandermonde matrix using the Proriol polynomials on the right triangle.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\n\nOutputs\n\nV: the Vandermonde matrix \nVdx,Vdy: derivatives of the Vandermonde matrix at (x,y)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_arnoldi","text":"OrthoPoly.vandermonde_arnoldi{T}\n\nEvaluate the Vandermonde with Arnoldi on the right tetrahedron.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y,z: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\n\nOutputs\n\nV: the Vandermonde matrix \nVdx,Vdy,Vdz: derivatives of the Vandermonde matrix at (x,y,z)\nHes: the Hessenberg matrix \n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_arnoldi","text":"OrthoPoly.vandermonde_arnoldi{T}\n\nEvaluate the Vandermonde with Arnoldi on the right triangle.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\n\nOutputs\n\nV: the Vandermonde matrix \nVdx, Vdy: derivatives of the Vandermonde matrix at (x,y)\nHes: the Hessenberg matrix \n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_arnoldi-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_arnoldi","text":"OrthoPoly.vandermonde_arnoldi{T}\n\nEvaluate the Vandermonde with Arnoldi on the line.\n\nInputs\n\np: the maximum total degree of the polynomial\nx: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\n\nOutputs\n\nV: the Vandermonde matrix \nVdx: derivatives of the Vandermonde matrix at (x)\nHes: the Hessenberg matrix \n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_full-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_full","text":"OrthoPoly.vandermonde_full{T}\n\nEvaluate the Vandermonde and complements it with the nullspace to create a full rank matrix.\n\nInputs\n\np: the maximum total degree of the polynomial\nx: locations at which to evaluate the derivative\n\nOutputs\n\nVfull: the full rank Vandermonde matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_monomial","text":"OrthoPoly.vandermonde_monomial{T}\n\nEvaluate the Vandermonde matrix using monomials on the right tetrahedron.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y,z: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\ncompute_integ: indicates whether to compute the integral of the monomial basis functions\n\nOutputs\n\nV: the Vandermonde matrix \nVdx,Vdy, Vdz: derivatives of the Vandermonde matrix at (x,y,z)\nVinteg: the integral of each basis function in the Vandermonde matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_monomial","text":"OrthoPoly.vandermonde_monomial{T}\n\nEvaluate the Vandermonde matrix using monomials on the right triangle.\n\nInputs\n\np: the maximum total degree of the polynomial\nx,y: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\ncompute_integ: indicates whether to compute the integral of the monomial basis functions\n\nOutputs\n\nV: the Vandermonde matrix \nVdx,Vdy: derivatives of the Vandermonde matrix at (x,y)\nVinteg: the integral of each basis function in the Vandermonde matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.OrthoPoly.vandermonde_monomial-Union{Tuple{T}, Tuple{Int64, Array{T}}} where T","page":"Reference","title":"SummationByParts.OrthoPoly.vandermonde_monomial","text":"OrthoPoly.vandermonde_monomial{T}\n\nEvaluate the Vandermonde matrix using monomials on the line.\n\nInputs\n\np: the maximum total degree of the polynomial\nx: locations at which to evaluate the derivative\ncompute_grad: indicates whether to compute the gradient of the Vandermonde matrix\ncompute_integ: indicates whether to compute the integral of the monomial basis functions\n\nOutputs\n\nV: the Vandermonde matrix \nVdx: derivatives of the Vandermonde matrix at (x)\nVinteg: the integral of each basis function in the Vandermonde matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#Outer-Constructors","page":"Reference","title":"Outer Constructors","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Constructors for the SBP operator classes.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# outerconstructor.jl\n# This file gathers together outer constructors for the SBP operators","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.getLineSegSBPLobbato\nSummationByParts.getLineSegSBPLegendre\nSummationByParts.getTriSBPGamma\nSummationByParts.getTriSBPOmega\nSummationByParts.getTriSBPDiagE\nSummationByParts.getTetSBPGamma\nSummationByParts.getTetSBPOmega\nSummationByParts.getTetSBPDiagE\nSummationByParts.getLineSegFace\nSummationByParts.TriFace\nSummationByParts.getTriFaceForDiagE\nSummationByParts.TetFace\nSummationByParts.getTetFaceForDiagE","category":"page"},{"location":"reference/#SummationByParts.getLineSegSBPLobbato","page":"Reference","title":"SummationByParts.getLineSegSBPLobbato","text":"SBP.getLineSegSBPLobbato\n\nReturns Gauss-Lobbato type elements, that have nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: a Gauss-Lobbato operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getLineSegSBPLegendre","page":"Reference","title":"SummationByParts.getLineSegSBPLegendre","text":"SBP.getLineSegSBPLegendre\n\nReturns Gauss-Legendre type elements, that do not have nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: a Legendre-Gauss operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTriSBPGamma","page":"Reference","title":"SummationByParts.getTriSBPGamma","text":"SBP.getTriSBPGamma\n\nReturns SBP-Gamma type elements, that have nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-Gamma operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTriSBPOmega","page":"Reference","title":"SummationByParts.getTriSBPOmega","text":"SBP.getTriSBPOmega\n\nReturns SBP-Omega type elements, that have no nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-Omega operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTriSBPDiagE","page":"Reference","title":"SummationByParts.getTriSBPDiagE","text":"SBP.getTriSBPDiagE\n\nReturns SBP-DiagE type elements, whose boundary nodes are positioned at cubature points\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-DiagE operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTetSBPGamma","page":"Reference","title":"SummationByParts.getTetSBPGamma","text":"SBP.getTetSBPGamma\n\nReturns SBP-Gamma type elements, that have nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-Gamma operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTetSBPOmega","page":"Reference","title":"SummationByParts.getTetSBPOmega","text":"SBP.getTetSBPOmega\n\nReturns SBP-Omega type elements, that have no nodes on the element boundary\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-Omega operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getTetSBPDiagE","page":"Reference","title":"SummationByParts.getTetSBPDiagE","text":"SBP.getTetSBPDiagE\n\nReturns SBP-DiagE type elements, whose boundary nodes are positioned at cubature points\n\nInputs\n\ndegree: maximum polynomial degree for which the derivatives are exact\nTsbp: floating point type used for the operators\n\nReturns\n\nsbp: an SBP-DiagE operator of the appropriate degree\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getLineSegFace","page":"Reference","title":"SummationByParts.getLineSegFace","text":"SBP.getLineSegFace\n\nReturns a trival face for line-segment elements.\n\nInputs\n\ndegree: face integration is exact for polys of degree 2*degree\nvolcub: cubature rule for the associated \"volume\"\nvtx: vertices of the line-segment\n\nReturns\n\nsbpface: an SBP face type for line-segment elements\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.TriFace","page":"Reference","title":"SummationByParts.TriFace","text":"SBP.TriFace\n\nDefines a face between two TriSBP operators with the same cubature nodes\n\nFields\n\ndegree : face integration is exact for polys of degree 2*degree\nnumnodes : number of cubature nodes\nstencilsize : number of nodes in the reconstruction stencil\ndstencilsize : number of nodes in the derivative operator stencils\ncub : a symmetric cubature type for triangle faces (i.e. edges)\nvtx : the vertices of the face in reference space, [-1,1]\nwface : mass matrix (quadrature) for the face\ninterp[:,:] : volume-to-face-nodes reconstruction operator\nperm[:,:] : permutation for volume nodes so interp can be used on all sides\nderiv[:,:] : derivative operators for face-based coordinate system\ndperm[:,:] : permutation for volume nodes so deriv can be used on all sides\nnbrperm[:,:] : permutation for face nodes on neighbour element\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.getTriFaceForDiagE","page":"Reference","title":"SummationByParts.getTriFaceForDiagE","text":"SBP.getTriFaceForDiagE\n\nReturns a quadrature that can be used to construct SBP operators with diagonal boundary operators, E.\n\nInputs\n\ndegree: face integration is exact for polys of degree 2*degree\nvolcub: cubature rule for the associated volume\nvtx: vertices of the triangle\nvertices: (optional) if true, the face cubature includes the vertices\n\nReturns\n\nsbpface: an SBP face type for triangle elements\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.TetFace","page":"Reference","title":"SummationByParts.TetFace","text":"SBP.TetFace\n\nDefines a face between two TetSBP operators with the same cubature nodes\n\nFields\n\ndegree : face integration is exact for polys of degree 2*degree\nnumnodes : number of cubature nodes\nstencilsize : number of nodes in the reconstruction stencil\ndstencilsize : number of nodes in the derivative operator stencils\ncub : a symmetric cubature type for tetrahedral faces (i.e. triangles)\nvtx : the vertices of the face in the reference space of the face\nwface : mass matrix (quadrature) for the face\ninterp[:,:] : volume-to-face-nodes reconstruction operator\nperm[:,:] : permutation for volume nodes so interp can be used on all sides\nderiv[:,:] : derivative operators for face-based coordinate system\ndperm[:,:] : permutation for volume nodes so deriv can be used on all sides\nnbrperm[:,:] : permutation for face nodes on neighbour element\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.getTetFaceForDiagE","page":"Reference","title":"SummationByParts.getTetFaceForDiagE","text":"SBP.getTetFaceForDiagE\n\nReturns a quadrature that can be used to construct SBP operators with diagonal boundary operators, E.\n\nInputs\n\ndegree: face integration is exact for polys of degree 2*degree+1\nvolcub: cubature rule for the associated volume\nvtx: vertices of the triangle\n\nReturns\n\nsbpface: an SBP face type for triangle elements\n\n\n\n\n\n","category":"function"},{"location":"reference/#SymCubatures-Module","page":"Reference","title":"SymCubatures Module","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Types and methods for mapping between symmetry groups and nodes for cubatures on various domains.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# symcubatures.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [SummationByParts.SymCubatures]","category":"page"},{"location":"reference/#SummationByParts.SymCubatures.LineSymCub","page":"Reference","title":"SummationByParts.SymCubatures.LineSymCub","text":"SymCubatures.LineSymCub\n\nDefines a symmetric quadrature rule on the interval [-1,1].  Current choices are Legendre-Gauss-Lobatto (LGL) or Legendre-Gauss (LG) rules.\n\nFields\n\nnumparams : total number of nodal degrees of freedom\nnumweights : total number of unique weights\nnumnodes : total number of nodes\nvertices : if true, vertices (ends of interval) are in the set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumsym : number of node sets in each symmetry group (2 for [-1,1])\nparams : the actual values of the orbit nodal parameters\nweights : values of the unique weights\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.OperType","page":"Reference","title":"SummationByParts.SymCubatures.OperType","text":"SymCubatures.OperType\n\nOperType is an abtract type that defines the type of SBP operators It has the subtypes Omega, Gamma, and DiagE. \n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.PointSymCub","page":"Reference","title":"SummationByParts.SymCubatures.PointSymCub","text":"SymCubatures.PointSymCub\n\nDefines the trivial point cubature for uniformity across methods.\n\nFields\n\nnumparams : total number of nodal degrees of freedom\nnumweights : total number of unique weights\nnumnodes : total number of nodes\nvertices : if true, vertices (ends of interval) are in the set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumsym : number of node sets in each symmetry group (0 for [1])\nparams : the actual values of the orbit nodal parameters\nweights : values of the unique weights\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.SymCub","page":"Reference","title":"SummationByParts.SymCubatures.SymCub","text":"SymCubatures.SymCub\n\nSymCub is an parametric abstract type that defines cubatures for symmetric nodal distributions.  It is parameterized on T in order to allow for future implementations of arbitrary precision types.  The parameterization also permits the use of the complex-step method for verification.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.TetSymCub","page":"Reference","title":"SummationByParts.SymCubatures.TetSymCub","text":"SymCubatures.TetSymCub\n\nUsed to define symmetric cubature rules on the tetrahedron.  The params array determines the position of the parameterized nodes, and the weights array determines the value of the weight for each symmetric orbit.  Note that boolean fields are used to activate some degenerate symmetry orbits.  For example, vertices are a special case of several of the orbits, and should be activated by setting vertices=true rather than relying on a specific value of a parameter.\n\nFields\n\nnumparams : total number of nodal degrees of freedom\nnumweights : total number of unique weights\nnumnodes : total number of nodes\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nfacecentroid : if true, face centroids are present in the set of nodes\nnumedge : number of unique edge parameters\nnumfaceS21 : number of S21 face orbits (same tri orbit on face)\nnumfaceS111 : number of S111 face orbits (same tri orbit on face)\nnumS31 : number of S31 orbits (vertex to opposite face)\nnumS22 : number of S22 orbits\nnumS211: number of S211 orbits\nnumS1111: number of S1111 orbits\nnumsym : number of node sets in each symmetry group (5 groups for Tet)\nparams : the actual values of the orbit nodal parameters\nweights : values of the unique weights\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.TriSymCub","page":"Reference","title":"SummationByParts.SymCubatures.TriSymCub","text":"SymCubatures.TriSymCub\n\nUsed to define symmetric cubature rules on the triangle.  The params array determines the position of the parameterized nodes, and the weights array determines the value of the weight for each symmetric orbit.  Note that boolean fields are used to activate some degenerate orbits.  For example, vertices are a special case of several of the orbits, and should be activated by setting vertices=true rather than relying on a specific value of a parameter.\n\nFields\n\nnumparams : total number of nodal degrees of freedom\nnumweights : total number of unique weights\nnumnodes : total number of nodes\nvertices : if true, vertices are present in the set of nodes\nmidedges : if true, edge midpoints are present in set of nodes\ncentroid : if true, centroid is present in set of nodes\nnumedge : number of unique edge parameters\nnumS21 : number of S21 orbits (vertex to opposite face)\nnumS111 : number of S111 orbits\nnumsym : number of node sets in each symmetry group (3 groups for Tri)\nparams : the actual values of the orbit nodal parameters\nweights : values of the unique weights\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SymCubatures.calcjacobian-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Matrix{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcjacobian","text":"SymCubatures.calcjacobian\n\nReturns the Jacobian of the nodal coordinates and weights with respect to their parameters.  In other words, returns the block-rectangular matrix [Jcoords, 0; 0, Jweights], where Jcoords is the Jacobian of the coordinates, Jweights is the Jacobian of the weights, and the 0s indicate zero blocks of the appropriate size.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the cubature domain\n\nOutputs\n\nJac: Jacobian of the nodal coordinates and weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.calcjacobianofnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Matrix{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcjacobianofnodes","text":"SymCubatures.calcjacobianofnodes\n\nReturns the Jacobian of the nodes with respect to the orbit parameters.\n\nNotes: Jac stores all the x-coordinate Jacobians first, then y (then z)\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices of the cubature domain\n\nOutputs\n\nJac: Jacobian of the mapping from node parameters to nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.calcjacobianofweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcjacobianofweights","text":"SymCubatures.calcjacobianofweights\n\nReturns the Jacobian of the nodal weights with respect to the unique weights. The resulting Jacobian is a rectangular matrix of ones and zeros that indicates the mapping from the unique weights to the nodal weights.\n\nInputs\n\ncub: symmetric cubature rule\n\nOutputs\n\nJac: Jacobian of the mapping from (unique) weights to nodal weights\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.calcnodes-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub, Matrix{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcnodes","text":"SymCubatures.calcnodes\n\nUse the orbital parameter values to compute a cubature's nodal coordinates.  The second dimension of the vtx array of vertices does not need to match the dimension as the cubature; for example, a line quadrature can be over a line in 1D, 2D, 3D or ND, and a triangle cubature can be in 2D, 3D, or ND, etc.\n\nInputs\n\ncub: symmetric cubature rule\nvtx: vertices that define the domain\n\nOutputs\n\nx: cubature's nodal coordinates (potentially in a subspace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.calcweights-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcweights","text":"SymCubatures.calcweights\n\nMap the unique cubature weights to the weights of all nodes.\n\nInputs\n\ncub: symmetric cubature rule\n\nOutputs\n\nw: cubature's weights at all nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.calcweights_symgroup-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.TriSymCub{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.calcweights_symgroup","text":"SymCubatures.calcweights_symgroup\n\nMap the cubature weights of all nodes to the unique weights of their symmetry groups.\n\nInputs\n\ncub: symmetric cubature rule\n\nOutputs\n\nw: cubature's weights of the symmetry group\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.findleftperm!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{Int64}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.findleftperm!","text":"SymCubatures.findleftperm!\n\nFor a matrix A, we are given a right permutation of the columns, A[:,permR]. This function attempts to find the left permultation of rows such that                       A[permL,:] = A[:,permR]\n\nInputs\n\nA: a rectangular matrix for which the left permutation is sought\npermR: the given right permutation of the columns\n\nOutputs\n\npermL: the left permutation of the rows, if it exists\n\nReturns\n\ntrue if the permutation exists, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getInternalParamMask-Union{Tuple{SummationByParts.SymCubatures.TriSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getInternalParamMask","text":"SymCubatures.getInternalParamMask\n\nReturns the set of parameter indices corresponding to internal nodes; this is useful when finding cubature rules for which we wish to fix the boundary nodes and only allow the internal nodes to move.\n\nInputs\n\ncub: symmetric cubature rule\n\nReturns\n\nmask: integer array of parameter indices associated with internal nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getbndrynodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getbndrynodeindices","text":"SymCubatures.getbndrynodeindices\n\nReturns the indices of the nodes that lie on the boundary, in their natural order.  See getfacenodeindices for a method returns node indices for each face.\n\nInputs\n\ncub: a symmetric cubature rule whose boundary-node indices are sought\n\nOutputs\n\nbndryindices: indicies of nodes that lie on boundary\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getfacebasedpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getfacebasedpermutation","text":"SymCubatures.getfacebasedpermutation\n\nReturns a permutation of the volume nodes (or a subset of them) for each face, such that the same face operator can be applied to all faces.  This is useful for volume-to-face interpolation or differentiation.\n\nInputs\n\ncub: a symmetric cubature rule for which a face-based permutation is sought\nfaceonly: if true, only face nodes are used in the permutation.\n\nOutputs\n\nperm: permutation of the volume nodes for each face\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getfacenodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getfacenodeindices","text":"SymCubatures.getfacenodeindices\n\nReturns the indices of the nodes that lie on each face.  See getbndrynodeindices for a method that returns a single array of boundary nodes.\n\nInputs\n\ncub: a symmetric cubature rule whose boundary-node indices are sought\n\nOutputs\n\nbndryindices: indicies of nodes that lie on boundary; there is a separate column of indices for each edge/face.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getfacevertexindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getfacevertexindices","text":"SymCubatures.getfacevertexindices\n\nReturns the indices of the vertices that make up each face.  This is useful when building nodes on a given face using Barycentric coordinates\n\nInputs\n\ncub: a symmetric cubature rule whose face vertices are sought\n\nOutputs\n\nfacevtx: subarray facevtx[:,f] lists the vertices of face f \n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getinteriornodeindices-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getinteriornodeindices","text":"SymCubatures.getinteriornodeindices\n\nReturns the indices of the nodes that are strictly interior.\n\nInputs\n\ncub: a symmetric cubature rule whose interior-node indices are sought\n\nOutputs\n\nindices: indicies of nodes that are strictly interior.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getneighbourpermutation-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getneighbourpermutation","text":"SymCubatures.getneighbourpermutation\n\nAt element interfaces, the cubature nodes of the common face will not match when natural ordering is provided.  This routine produces the permutation that makes the 'right' element's nodes match the 'left' element's nodes.  The permutation depends on the face dimension:\n\nFor line segment faces, i.e. points, a trival permutation is returned\nFor triangle faces, i.e. line segments, there is only one possible orientation.\nFor tetrahedral faces, i.e. triangles, there are three orientations:\n\nThe \"1\" vertex from each element's face is coincident;\nThe \"1\" vertex from face 1 coincides with \"2\" vertex from face 2;\nThe \"1\" vertex from face 1 coincides with \"3\" vertex from face 2.\n\nInputs\n\ncub: a symmetric cubature rule for which the permutation is sought\n\nOutputs\n\nperm: permutation of the interface nodes for each possible orientation\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getnumboundarynodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getnumboundarynodes","text":"SymCubatures.getnumboundarynodes\n\nReturns the number of (explicit) boundary nodes\n\nNotes: if the parameter value for an internal orbit is such that the corresponding node lies on the boundary, this node is NOT included in the boundary-node count returned.\n\nInputs\n\ncub: symmetric cubature rule\n\nOutputs\n\nnumboundary: number of boundary nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getnumfacenodes-Union{Tuple{SummationByParts.SymCubatures.PointSymCub{T}}, Tuple{T}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getnumfacenodes","text":"SymCubatures.getnumfacenodes\n\nReturns the number of nodes on an individual face of the element.\n\nInputs\n\ncub: symmetric cubature rule\n\nOutputs\n\nnumfacenodes: number of nodes on a face\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.getpermutation-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.PointSymCub{T}, Vector{Int64}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.getpermutation","text":"SymCubatures.getpermutation\n\nReturns a permutation of the cubature nodes based on a reordering of the vertices from their canonical orientation.  That is, finds the node ordering such that the new nodes have the same order as the old nodes, but relative to vtxperm.  This is useful for face-based operations.\n\nInputs\n\ncub: a symmetric cubature rule for which the permutation is sought\nvtxperm: the permutation that is applied to the vertices\n\nOutputs\n\nperm: permutation of the cubature nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.setparams!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.setparams!","text":"SymCubatures.setparams!\n\nSets the nodal parameters for any parameterized symmetry orbits in the cubature.\n\nInputs\n\nparams: parameter values\n\nIn/Outs\n\ncub: symmetric cubature rule whose nodal parameters are being updated\n\n\n\n\n\n","category":"method"},{"location":"reference/#SummationByParts.SymCubatures.setweights!-Union{Tuple{T}, Tuple{SummationByParts.SymCubatures.SymCub{T}, Array{T}}} where T","page":"Reference","title":"SummationByParts.SymCubatures.setweights!","text":"SymCubatures.setweights!\n\nSets a cubature's (unique) weights.\n\nInputs\n\nweights: cubature weights grouped by orbit\n\nIn/Outs\n\ncub: symmetric cubature rule whose weights are being updated\n\n\n\n\n\n","category":"method"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"SBP abstract and concrete type definitions.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# sbp_types.jl\n# SBP abstract and concrete type definitions","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.AbstractSBP\nSummationByParts.LineSegSBP\nSummationByParts.TriSBP\nSummationByParts.SparseTriSBP\nSummationByParts.TetSBP\nSummationByParts.SparseTetSBP\nSummationByParts.AbstractFace\nSummationByParts.DenseFace\nSummationByParts.LineSegFace\nSummationByParts.TriFace\nSummationByParts.TetFace\nSummationByParts.SparseFace\nSummationByParts.TriSparseFace\nSummationByParts.TetSparseFace","category":"page"},{"location":"reference/#SummationByParts.AbstractSBP","page":"Reference","title":"SummationByParts.AbstractSBP","text":"SBP.AbstractSBP\n\nAbstractSBP is a parametric abstract type that defines summation-by-parts finite-difference operators.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.LineSegSBP","page":"Reference","title":"SummationByParts.LineSegSBP","text":"SBP.LineSegSBP\n\nDefines diagonal-norm SBP first-derivative operators on a line segment.\n\nFields\n\ndegree : maximum polynomial degree for which the derivatives are exact\nnumnodes : number of nodes on line segment required for these operators\ncub : a symmetric cubature type for line segments (usually LG or LGL)\nvtx : vertices of the reference element in computational space\nw : cubature weights, i.e. the diagonal SBP norm, stored as an array\nQ[:,:,1] : discrete stiffness matrix operator\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.TriSBP","page":"Reference","title":"SummationByParts.TriSBP","text":"SBP.TriSBP\n\nDefines diagonal-norm SBP first-derivative operators on a right-triangle.\n\nFields\n\ndegree : maximum polynomial degree for which the derivatives are exact\nnumnodes : number of nodes in the triangle required for these operators\ncub : a symmetric cubature type for triangles\nvtx : vertices of the reference element in computational space\nw : cubature weights, i.e. the diagonal SBP norm, stored as an array\nQ[:,:,i] : discrete stiffness matrix operator in ith coordinate direction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SparseTriSBP","page":"Reference","title":"SummationByParts.SparseTriSBP","text":"SBP.SparseTriSBP\n\nDefines diagonal-norm SBP first-derivative operators on a right-triangle using a cubature rule that is greater than 2*p-1.  This provides additional flexiblity in the SBP operator that is used to make a sparse S.\n\nFields\n\ndegree : maximum polynomial degree for which the derivatives are exact\nnumnodes : number of nodes in the triangle required for these operators\ncub : a symmetric cubature type for triangles\nvtx : vertices of the reference element in computational space\nw : cubature weights, i.e. the diagonal SBP norm, stored as an array\nQ[:,:,i] : discrete stiffness matrix operator in ith coordinate direction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.TetSBP","page":"Reference","title":"SummationByParts.TetSBP","text":"SBP.TetSBP\n\nDefines diagonal-norm SBP first-derivative operators on a right-tetrahedron.\n\nFields\n\ndegree : maximum polynomial degree for which the derivatives are exact\nnumnodes : number of nodes in the tetrahedron required for these operators\ncub : a symmetric cubature type for tetrahedra\nvtx : vertices of the reference element in computational space\nw : cubature weights, i.e. the diagonal SBP norm, stored as an array\nQ[:,:,i] : discrete stiffness matrix operator in ith coordinate direction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SparseTetSBP","page":"Reference","title":"SummationByParts.SparseTetSBP","text":"SBP.SparseTetSBP\n\nDefines diagonal-norm SBP first-derivative operators on a right-tetrahedron using a cubature rule that is greater than 2*p-1.  This provides additional flexiblity in the SBP operator that is used to make a sparse S.\n\nFields\n\ndegree : maximum polynomial degree for which the derivatives are exact\nnumnodes : number of nodes in the tetrahedron required for these operators\ncub : a symmetric cubature type for tetrahedra\nvtx : vertices of the reference element in computational space\nw : cubature weights, i.e. the diagonal SBP norm, stored as an array\nQ[:,:,i] : discrete stiffness matrix operator in ith coordinate direction\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.AbstractFace","page":"Reference","title":"SummationByParts.AbstractFace","text":"SBP.AbstractFace\n\nAbstractFace is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.DenseFace","page":"Reference","title":"SummationByParts.DenseFace","text":"SBP.DenseFace\n\nDenseFace is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators.  This is a subtype for which interpolation is a dense matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.LineSegFace","page":"Reference","title":"SummationByParts.LineSegFace","text":"SBP.LineSegFace\n\nDefines a \"face\" between two LineSegSBP operators with the same cubature nodes.\n\nFields\n\ndegree : face integration is exact for polys of degree 2*degree\nnumnodes : number of cubature nodes (always 1)\nstencilsize : number of nodes in the reconstruction stencil\ndstencilsize : number of nodes in the derivative operator stencils\ncub : a symmetric cubature type for line-segment faces (i.e. points)\nvtx : the vertices of the face in reference space, [-1]\nwface : mass matrix (quadrature) for the face (always 1.0)\ninterp[:,:] : volume-to-face-nodes reconstruction operator\nperm[:,:] : permutation for volume nodes so interp can be used on both sides\nderiv[:,:] : derivative operators for face-based coordinate system\ndperm[:,:] : permutation for volume nodes so deriv can be used on both sides\nnbrperm[:,:] : permutation for face nodes on neighbour element\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.SparseFace","page":"Reference","title":"SummationByParts.SparseFace","text":"SBP.SparseFace\n\nSparseFace is a parametric abstract type that defines face-based data and operations (e.g. volume-to-face reconstruction, face integration, etc) for summation-by-parts finite-difference operators in the case where the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.TriSparseFace","page":"Reference","title":"SummationByParts.TriSparseFace","text":"SBP.TriSparseFace\n\nDefines a face between two TriSBP operators with the same cubature nodes, in which the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).\n\nFields\n\ndegree : face integration is exact for polys of degree 2*degree\nnumnodes : number of cubature nodes\ndstencilsize : number of nodes in the derivative operator stencils\ncub : a symmetric cubature type for triangle faces (i.e. edges)\nvtx : the vertices of the face in reference space, [-1,1]\nwface : mass matrix (quadrature) for the face\nperm[:,:] : maps volume nodes to face nodes on each side\nderiv[:,:] : derivative operators for face-based coordinate system\ndperm[:,:] : permutation for volume nodes so deriv can be used on all sides\nnbrperm[:,:] : permutation for face nodes on neighbour element\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.TetSparseFace","page":"Reference","title":"SummationByParts.TetSparseFace","text":"SBP.TetSparseFace\n\nDefines a face between two TetSBP operators with the same cubature nodes, in which the face-cubature nodes and volume nodes coincide (i.e. diagonal E operators).\n\nFields\n\ndegree : face integration is exact for polys of degree 2*degree\nnumnodes : number of cubature nodes\ndstencilsize : number of nodes in the derivative operator stencils\ncub : a symmetric cubature type for tetrahedral faces (i.e. triangles)\nvtx : the vertices of the face in the reference space of the face\nwface : mass matrix (quadrature) for the face\nperm[:,:] : permutation for volume nodes to face nodes on each side\nderiv[:,:] : derivative operators for face-based coordinate system\ndperm[:,:] : permutation for volume nodes so deriv can be used on all sides\nnbrperm[:,:] : permutation for face nodes on neighbour element\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Reference","title":"Reference","text":"# face_types.jl\n# These are from ODLCommonTools; we can return to using that package when\n# it is brought up-to-date","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.Boundary\nSummationByParts.Interface","category":"page"},{"location":"reference/#SummationByParts.Boundary","page":"Reference","title":"SummationByParts.Boundary","text":"ODLCommonTools.Boundary\n\nUsed to identify boundary faces in a finite-element grid.\n\nFields\n\nelement : index of the element to which the boundary face belongs\nface : the face index of the boundary (local index to the element)\n\nExample\n\nTo mark face 2 of element 7 to be a boundary face, use Boundary(7,2)\n\n\n\n\n\n","category":"type"},{"location":"reference/#SummationByParts.Interface","page":"Reference","title":"SummationByParts.Interface","text":"ODLCommonTools.Interface\n\nUsed to identify interfaces between elements in a finite-element grid.\n\nFields\n\nelementL : index of the so-called left element in the pair\nelementR : index of the so-called right element in the pair\nfaceL : the face index of the interface with respect to the left element\nfaceR : the face index of the interface with respect to the right element\norient : orientation of the 'right' element relative to the 'left'\n\nExample\n\nConsider an interface between elements 2 and 5.  Suppose the interface is on face 1 of element 2 and face 3 of element 5.  Furthermore, suppose element 5 has orientation 1 relative to element 1 (defintion of orientation TBD).  This can be indicated as Interface(2,5,1,3,1)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Functions that are not easily categorized.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"# utils.jl\n# This file gathers together a hodge-podge of functions that are not easily\n# categorized","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"SummationByParts.getNumFaceNodes\nSummationByParts.getnbrnodeindex\nSummationByParts.calcnodes\nSummationByParts.calcminnodedistance\nSummationByParts.buildinterpolation\nSummationByParts.permuteinterface!\nSummationByParts.permuteface!\nSummationByParts.basispursuit!\nSummationByParts.calcSparseSolution!\nSummationByParts.absMatrix!\nSummationByParts.calcMatrixEigs!\nSummationByParts.calcMatrixEigs_rev!\nSummationByParts.conditionObj\nSummationByParts.conditionObjGrad!\nSummationByParts.eigenvalueObj\nSummationByParts.eigenvalueObjGrad!\nSummationByParts.truncErr\nSummationByParts.computeConditionNumber\nSummationByParts.pocs_sparse_s\nSummationByParts.quadTruncErr\ncheckInteriorNodeLocaton","category":"page"},{"location":"reference/#SummationByParts.getNumFaceNodes","page":"Reference","title":"SummationByParts.getNumFaceNodes","text":"SummationByParts.getNumFaceNodes\n\nReturns the number of SBP element nodes on a face.\n\nInputs\n\nsbp: an SBP operator\n\nReturns\n\nnumfacenodes: number of nodes on (one) face of the element\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.getnbrnodeindex","page":"Reference","title":"SummationByParts.getnbrnodeindex","text":"SummationByParts.getnbrnodeindex\n\nReturns the face-node index on face.faceR equivalent to index i on face.faceL.\n\nInputs\n\nsbp: an SBP operator\nface: an element interface\ni: face-node index on face.faceL\n\nReturns\n\nj: face-node index on face.faceR\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcnodes","page":"Reference","title":"SummationByParts.calcnodes","text":"SummationByParts.calcnodes\n\nThis function returns the node coordinates for an SBP operator.  It basically calls calcnodes for the underlying SymCubature.  This function assumes the element mapping is linear, i.e. edges are lines.\n\nInputs\n\nsbp: an SBP operator\nvtx: the vertices that define the element\n\nOutputs\n\nx: the node coordinates; 1st dimension is the coordinate, the second the node\n\nExample\n\n  # define a third-order accurate SBP on triangles\n  sbp = TriSBP{Float64}(degree=2)\n  # build a simple 2-element grid on a square domain\n  x = zeros(Float64, (2,sbp.numnodes,2))\n  vtx = [0. 0.; 1. 0.; 0. 1.]\n  x[:,:,1] = calcnodes(sbp, vtx)\n  vtx = [1. 0.; 1. 1.; 0. 1.]\n  x[:,:,2] = calcnodes(sbp, vtx)\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcminnodedistance","page":"Reference","title":"SummationByParts.calcminnodedistance","text":"SummationByParts.calcminnodedistance\n\nReturns the minimum distance between distinct nodes on an element with straight sides\n\nInputs\n\nsbp: an SBP operator\nvtx: the vertices that define the element\n\nReturns\n\nmindist: the minimum distance between distinct nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.buildinterpolation","page":"Reference","title":"SummationByParts.buildinterpolation","text":"SummationByParts.buildinterpolation\n\nBuilds a matrix operator that can reconstruct a field located at the sbp nodes to an auxlliary set of nodes.\n\nInputs\n\nsbp: an SBP operator\nxinterp: points to interpolate to in ref coords, size = [ndim,numpoints]\nd=sbp.degree: (optional) interpolation is exact for degree d polys\n\nReturns\n\nR: the interpolation operator, size = [numpoints, sbp.numnodes]\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.permuteinterface!","page":"Reference","title":"SummationByParts.permuteinterface!","text":"SummationByParts.permuteinterface!\n\nFor a given array of values on a faces, permutes the node values (in place) to  be in the orientation specified by the orient field of the corresponding  Interface.  Methods are available for scalar and vector fields.\n\nInputs\n\nsbp: an SBPFace operator\nifaces: an array of Interfaces\n\nIn/Outs\n\nuface: the array of face values, must have dimensions          [n x sbpface.numnodes x length(ifaces] if 3D array (where n          is arbitrary) or [sbpface.numnodes x length(ifaces] if 2D.            The permutation is applied to the second array dimension for the           3D case or the first dimension in the 2D case.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.permuteface!","page":"Reference","title":"SummationByParts.permuteface!","text":"SummationByParts.permuteface!\n\nThis function applys a permutation to the data on a particular face.\n\nInputs\n\npermvec: vector specifying the permutation to apply\nworkarr: a temporary array, same size as face_data, that is overwritten            during the computation\n\nIn/Outs\n\nface_data: an N-D array containing the data to be pemuted, where the             permutation is applied to the second dimension of the array             for N=2 and the first dimension if N=1.  N > 2 is not             currently supported\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.basispursuit!","page":"Reference","title":"SummationByParts.basispursuit!","text":"SummationByParts.basispursuit!\n\nFinds an approximate solution to the underdetermined problem Ax = b that is sparse using the alternating direction method of multipliers (ADMM).\n\nInputs\n\nA: matrix in the linear equation that must be satisfied\nb: vector in the linear equation that must be satisfied\nrho (optional) : augmented Lagrangian parameter\nalpha (optional) : over-relaxation parameter (usually between 1.0 and 1.8)\nhist (optional): output the convergence history to the terminal\nabstol (optional): absolute tolerance\nreltol (optional): relative tolerance\n\nIn/Outs\n\nx: sparse solution of the problem\n\nNotes\n\nThis is a direct translation of Boyd et al's Matlab implementation of ADMM for basis pursuit.  This method is not well suited to high-accuracy solutions, so, for our purposes, it is best used as a means of identifying the sparsity pattern.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcSparseSolution!","page":"Reference","title":"SummationByParts.calcSparseSolution!","text":"SummationByParts.calcSparseSolution!\n\nFinds a solution to the underdetermined problem Ax = b that is sparse.  Uses basispursit! to find an approximate solution, which is used to eliminate columns from A, from which an accurate solution is found.\n\nInputs\n\nA: matrix in the linear equation that must be satisfied\nb: vector in the linear equation that must be satisfied\n\nIn/Outs\n\nx: sparse solution of the problem\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.absMatrix!","page":"Reference","title":"SummationByParts.absMatrix!","text":"SummationByParts.absMatrix!\n\nComputes the absolulte value of a symmetric matrix A; that is, using the eigenvalue factorization A = EΛE^T, this function returns Aabs = E|Λ|E^T, where |Λ| is the elementwise absolute value applied to the diagonal eigenvalue matrix.\n\nInputs\n\nA: symmetric matrix whose absolute value is sought\n\nIn/Outs\n\nAabs: matrix where the absolute value is stored\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcMatrixEigs!","page":"Reference","title":"SummationByParts.calcMatrixEigs!","text":"SummationByParts.calcMatrixEigs!\n\nFinds the eigenvalues of the given matrix in order of increasing modulus; that is, this works for symmetric and non-symmetric square matrices.  This method is basically a front end for eigfact.\n\nInputs\n\nA: matrix whose eigenvalues are desired\n\nIn/Outs\n\nλ: eigenvalues of A sorted in increasing modulus\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.calcMatrixEigs_rev!","page":"Reference","title":"SummationByParts.calcMatrixEigs_rev!","text":"SummationByParts.calcMatrixEigs_rev!\n\nThe reverse-mode differentiated version of calcMatrixEigs!.  The math behind this is from Mike Giles report \"An extended collection of matrix derivative results for forward and reverse mode algorithmic differentiation.\"\n\nInputs\n\nA: matrix whose eigenvalues are desired\nλ_bar: ∂f/∂λ vector that multiplies derivatives from left\n\nIn/Outs\n\nλ: eigenvalues of A sorted in increasing modulus\nA_bar: derivatives ∂f/∂A\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.conditionObj","page":"Reference","title":"SummationByParts.conditionObj","text":"SummationByParts.conditionObj\n\nLet x = Znull*xred + xperp be the (unique) entries in a skew symmetric matrix S, and let E be a symmetric positive-definite matrix.  This routine computes an approximation of the condition number of the matrix A = (S + E).  The matrix A corresponds to a weak-form discretization of linear advection.  The condition number is approximated using KS aggregation to ensure the objective is differentiable.\n\nInputs\n\nxred: a reduced-space for the entries in the skew-symmetric matrix\np: defines the KS parameter; as p tends to infinity, we get obj = kappa(A)\nxperp: a particular solution that satisfies the SBP accuracy conditions\nZnull: matrix that defines the null-space of the SBP accuracy conditions\nE: symmetric positive-definite matrix (boundary operator for an SBP matrix)\n\nReturns\n\nobj: approximate condition number of A as defined above.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.conditionObjGrad!","page":"Reference","title":"SummationByParts.conditionObjGrad!","text":"SummationByParts.conditionObjGrad!\n\nComputes the gradient of the function conditionObj with respect to xred, and returns it in the array g.\n\nInputs\n\nxred: a reduced-space for the entries in the skew-symmetric matrix\np: defines the KS parameter; as p tends to infinity, we get obj = kappa(A)\nxperp: a particular solution that satisfies the SBP accuracy conditions\nZnull: matrix that defines the null-space of the SBP accuracy conditions\nE: symmetric positive-definite matrix (boundary operator for an SBP matrix)\n\nIn/Outs\n\ng: gradient of the objective conditionObj with respect to xred\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.eigenvalueObj","page":"Reference","title":"SummationByParts.eigenvalueObj","text":"SummationByParts.eigenvalueObj\n\nLet x = Znullxred + xperp be the (unique) entries in a skew symmetric matrix S, and let E be a symmetric matrix.  This routine returns the spectral radius of the matrix A = diagm(1./w)(S + |E|), where |⋅| is the elementwise absolute value.  The matrix A corresponds to a strong-form discretization of linear advection.\n\nInputs\n\nxred: a reduced-space for the entries in the skew-symmetric matrix\np: not used presently\nxperp: a particular solution that satisfies the SBP accuracy conditions\nZnull: matrix that defines the null-space of the SBP accuracy conditions\nw: diagonal norm entries in an SBP operator\nE: symmetric matrix, usually the boundary operator for an SBP matrix\n\nReturns\n\nobj: the 2p-norm of the moduli of the eigenvalues of A as defined above.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.eigenvalueObjGrad!","page":"Reference","title":"SummationByParts.eigenvalueObjGrad!","text":"SummationByParts.eigenvalueObjGrad!\n\nComputes the gradient of the function eigenvalueObj with respect to xred, and returns it in the array g.\n\nInputs\n\nxred: a reduced-space for the entries in the skew-symmetric matrix\np: not used at present\nxperp: a particular solution that satisfies the SBP accuracy conditions\nZnull: matrix that defines the null-space of the SBP accuracy conditions\nw: diagonal norm entries in an SBP operator\nE: symmetric matrix, usually the boundary operator for an SBP matrix\n\nIn/Outs\n\ng: gradient of the objective eigenvalueObj with respect to xred\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.truncErr","page":"Reference","title":"SummationByParts.truncErr","text":"SummationByParts.truncErr\n\nThis function computes the truncation error from the derivative operator.\n\nInputs\n\nd: the degree of the operator\nx: the coordinates of the quadrature points\nw: the weights of the quadrature rule\nQ: the weak differentiation matrices\n\nIn/Outs\n\ntrunc_err: the truncation error\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.computeConditionNumber","page":"Reference","title":"SummationByParts.computeConditionNumber","text":"SummationByParts.computeConditionNumber\n\nThis function computes the condition number of A=S+E for operators on triangular elements.\n\nInputs\n\np: the degree of the operator\nopertype: the SBP operator family type\nvtx: the vertices of the \nvertices: indicates whether vertices are included\n\nIn/Outs\n\ncondA: the condition number of A=S+E\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.pocs_sparse_s","page":"Reference","title":"SummationByParts.pocs_sparse_s","text":"SummationByParts.pocssparses\n\nThis function uses the Projection Onto Convex Sets (POCS) algorithm to construct a sparse skew-symmetric S matrix.\n\nInputs\n\nS: the skew-symmetric matrix\nH: the norm/mass matrix\nE: the boundary integration matrix\nV: the Vandermonde matrix\nVdx: the gradient of the Vandermonde matrix\n\nIn/Outs\n\nS: the sparsified skew-symmetric matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.quadTruncErr","page":"Reference","title":"SummationByParts.quadTruncErr","text":"SummationByParts.quadTruncErr\n\nThis function computes the integration truncation error of the quadrature rule on the right triangle or tetrahedron.\n\nInputs\n\ncub: a symmetric cubature for the right triangle\nq: the quadarature degree\n\nIn/Outs\n\nquadTruncErr: the quadature truncation error\n\n\n\n\n\n","category":"function"},{"location":"reference/#SummationByParts.checkInteriorNodeLocaton","page":"Reference","title":"SummationByParts.checkInteriorNodeLocaton","text":"SummationByParts.checkInteriorNodeLocaton\n\nThis function checks if all interior nodes are within the interior of the right triangle or tetrahedron; i.e., not outside or on the boundaries.\n\nInputs\n\ncub: a symmetric cubature for the right triangle\nvtx: the vertices of the triangle\n\nNote: The vertex is assumed to be on [-1,1] interval in each dimension\n\n\n\n\n\n","category":"function"},{"location":"#SummationByParts","page":"Home","title":"SummationByParts","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SummationByParts is a Julia package that implements summation-by-parts (SBP) operators, which can be used to construct stable, high-order discretizations of partial differential equations. SBP operators are finite-difference operators, but they share much in common with finite-element operators. For more information about SBP methods, the following reviews are a great place to start:","category":"page"},{"location":"","page":"Home","title":"Home","text":"M. Svärd and Jan Nordström, \"Review of summation-by-parts schemes for initial–boundary-value problems,\" Journal of Computational Physics, July, 2014.\nD. Del Rey Fernández, J. Hicken, and D. Zingg, \"Review of summation-by-parts operators with simultaneous approximation terms for the numerical solution of partial differential equations,\" Computers & Fluids, May, 2014.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package focuses on multidimensional SBP operators for the triangle and tetrahedral.  For the theory behind multidimensional SBP operators, please see:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J. Hicken, D. Del Rey Fernández, and D. Zingg, \"Multidimensional Summation-by-Parts Operators: General Theory and Application to Simplex Elements,\" SIAM Journal on Scientific Computing, July 06, 2016.\nD. Del Rey Fernández, J. Hicken, and D. Zingg, \"Simultaneous Approximation Terms for Multi-dimensional Summation-by-Parts Operators,\" Journal of Scientific Computing, 2018.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SummationByParts also provides functionality to construct high-order symmetric quadrature rules with positive weights on simplices. For details on construction of such quadrature rules, please see: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z. Worku, J. Hicken, D. Zingg, \"Quadrature Rules on Triangles and Tetrahedra for Multidimensional Summation-By-Parts Operators,\" Submitted to Journal of Scientific Computing, 2024.","category":"page"},{"location":"#Using-the-Package","page":"Home","title":"Using the Package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following documentation provides a brief overview of how to use the SummationByParts package.  This assumes the user has some familiarity with Julia. ","category":"page"},{"location":"#Building-SBP-operators","page":"Home","title":"Building SBP operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The construction of an SBP operator is best explained with an example.  The following code produces a degree 3 (order 4) SBP operator on a triangle.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SummationByParts\nsbp = SummationByParts.getTriSBPDiagE(degree=3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is another example, which shows how to construct a degree 2 SBP element on a tetrahedron (in this example, it has been assumed that the using SummationByParts statement has already been executed).","category":"page"},{"location":"","page":"Home","title":"Home","text":"sbp = SummationByParts.getTetSBPDiagE(degree=2,Tsbp=Float64)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SBP operators are parametrized; hence, one can specify the their type as examplified by the use of Float64.  This means that the matrix fields inside the sbp type are Float64 arrarys. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In general, we recommend using the SBP operators with methods provided by the package and that users do not rely on the fields of the sbp type directly.  This is because we may, in the future, change the fields to support different SBP operators (or some fields may become obsolete).  Nevertheless, for those who are curious, here is a partial list of the most important fields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sbp.degree : maximum polynomial degree for which the derivatives are exact\nsbp.numnodes : number of nodes for the operator\nsbp.vtx : vertices of the reference element in computational space\nsbp.w : cubature weights, i.e. the diagonal SBP norm, stored as an array\nsbp.Q[:,:,i] : discrete stiffness matrix operator in ith coordinate ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information on the usage of the SummationByPart.jl package, please refer to the examples.","category":"page"}]
}
